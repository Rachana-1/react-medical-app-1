{"ast":null,"code":"var HierarchyClosure = function () {\n  /** create a hierarchy object\n   * This object keeps track of direct children and parents as well as transitive children and parents.\n   */\n  function makeHierarchy() {\n    var roots = {};\n    var parents = {};\n    var children = {};\n    var holders = {};\n    return {\n      add: function add(parent, child) {\n        if ( // test if this is a novel entry.\n        parent in children && children[parent].indexOf(child) !== -1) {\n          return;\n        }\n\n        var target = parent in holders ? getNode(parent) : roots[parent] = getNode(parent); // add new parents to roots.\n\n        var value = getNode(child);\n        target[child] = value;\n        delete roots[child]; // // maintain hierarchy (direct and confusing)\n        // children[parent] = children[parent].concat(child, children[child])\n        // children[child].forEach(c => parents[c] = parents[c].concat(parent, parents[parent]))\n        // parents[child] = parents[child].concat(parent, parents[parent])\n        // parents[parent].forEach(p => children[p] = children[p].concat(child, children[child]))\n        // maintain hierarchy (generic and confusing)\n\n        updateClosure(children, parents, child, parent);\n        updateClosure(parents, children, parent, child);\n\n        function updateClosure(container, members, near, far) {\n          container[far] = container[far].filter(function (e) {\n            return (\n              /* e !== near && */\n              container[near].indexOf(e) === -1\n            );\n          }).concat(container[near].indexOf(near) === -1 ? [near] : [], container[near]);\n          container[near].forEach(function (n) {\n            return members[n] = members[n].filter(function (e) {\n              return e !== far && members[far].indexOf(e) === -1;\n            }).concat(members[far].indexOf(far) === -1 ? [far] : [], members[far]);\n          });\n        }\n\n        function getNode(node) {\n          if (!(node in holders)) {\n            parents[node] = [];\n            children[node] = [];\n            holders[node] = {};\n          }\n\n          return holders[node];\n        }\n      },\n      roots: roots,\n      parents: parents,\n      children: children\n    };\n  }\n\n  function depthFirst(n, f, p) {\n    return Object.keys(n).reduce(function (ret, k) {\n      return ret.concat(depthFirst(n[k], f, k), p ? f(k, p) : []); // outer invocation can have null parent\n    }, []);\n  }\n\n  return {\n    create: makeHierarchy,\n    depthFirst: depthFirst\n  };\n}();\n/* istanbul ignore next */\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\n  module.exports = HierarchyClosure;\n}","map":null,"metadata":{},"sourceType":"script"}