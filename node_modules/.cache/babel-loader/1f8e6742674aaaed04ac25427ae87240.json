{"ast":null,"code":"import _regeneratorRuntime from \"D:\\\\Downloads\\\\Test HTML\\\\react-medical-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"D:\\\\Downloads\\\\Test HTML\\\\react-medical-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { AccessControlList, ACLFactory, AppPermission } from '@inrupt/solid-react-components';\nimport { errorToaster } from \"./\"; // Check that all permissions we need are set. If any are missing, this returns false\n\nvar checkAppPermissions = function checkAppPermissions(userAppPermissions, appPermissions) {\n  return appPermissions.every(function (permission) {\n    return userAppPermissions.includes(permission);\n  });\n}; // Function to check for a specific permission included in the app\n\n\nexport var checkSpecificAppPermission = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(webId, permission) {\n    var userAppPermissions;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return AppPermission.checkPermissions(webId);\n\n          case 2:\n            userAppPermissions = _context.sent;\n            return _context.abrupt(\"return\", userAppPermissions.permissions.includes(permission));\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function checkSpecificAppPermission(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * SDK app will need all the permissions by the user pod so we check these permissions to work without any issues.\n * Error Message object is to hold the title, message, etc strings, as we can't use i18n libraries in this non-React file\n */\n\nexport var checkPermissions = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(webId, errorMessage) {\n    var userApp, permissions, APPEND, READ, WRITE, CONTROL;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return AppPermission.checkPermissions(webId);\n\n          case 2:\n            userApp = _context2.sent;\n\n            /**\n             * Get modes permissions from solid-react-components\n             */\n            permissions = AccessControlList.MODES;\n            APPEND = permissions.APPEND, READ = permissions.READ, WRITE = permissions.WRITE, CONTROL = permissions.CONTROL; // If we are missing permissions that the app requires, display an error message with a Learn More link\n\n            if (userApp === null || userApp.permissions === null || !checkAppPermissions(userApp.permissions, [APPEND, READ, WRITE, CONTROL])) {\n              errorToaster(errorMessage.message, errorMessage.title, {\n                label: errorMessage.label,\n                href: errorMessage.href\n              });\n            }\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function checkPermissions(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Helper function to fetch permissions for the game inbox, and if permissions are not set\n * correctly, then add them. This repairs a broken inbox.\n * @param inboxPath\n * @returns {Promise<void>}\n */\n\nexport var checkOrSetInboxAppendPermissions = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(inboxPath, webId) {\n    var inboxAcls, permissions, inboxPublicPermissions, appendPermission, _permissions, ACLFile;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return ACLFactory.createNewAcl(webId, inboxPath);\n\n          case 2:\n            inboxAcls = _context3.sent;\n            _context3.next = 5;\n            return inboxAcls.getPermissions();\n\n          case 5:\n            permissions = _context3.sent;\n            inboxPublicPermissions = permissions.filter(function (perm) {\n              return perm.agents === null;\n            });\n            appendPermission = inboxPublicPermissions.filter(function (perm) {\n              return perm.modes.includes(AccessControlList.MODES.APPEND);\n            });\n\n            if (!(appendPermission.length <= 0)) {\n              _context3.next = 21;\n              break;\n            }\n\n            _context3.prev = 9;\n            // Permission object to add. A null agent means Everyone\n            _permissions = [{\n              agents: null,\n              modes: [AccessControlList.MODES.APPEND]\n            }];\n            _context3.next = 13;\n            return ACLFactory.createNewAcl(webId, inboxPath);\n\n          case 13:\n            ACLFile = _context3.sent;\n            _context3.next = 16;\n            return ACLFile.createACL(_permissions);\n\n          case 16:\n            _context3.next = 21;\n            break;\n\n          case 18:\n            _context3.prev = 18;\n            _context3.t0 = _context3[\"catch\"](9);\n            throw _context3.t0;\n\n          case 21:\n            return _context3.abrupt(\"return\", true);\n\n          case 22:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[9, 18]]);\n  }));\n\n  return function checkOrSetInboxAppendPermissions(_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["D:/Downloads/Test HTML/react-medical-app/src/utils/permissions.js"],"names":["AccessControlList","ACLFactory","AppPermission","errorToaster","checkAppPermissions","userAppPermissions","appPermissions","every","permission","includes","checkSpecificAppPermission","webId","checkPermissions","permissions","errorMessage","userApp","MODES","APPEND","READ","WRITE","CONTROL","message","title","label","href","checkOrSetInboxAppendPermissions","inboxPath","createNewAcl","inboxAcls","getPermissions","inboxPublicPermissions","filter","perm","agents","appendPermission","modes","length","ACLFile","createACL"],"mappings":"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","sourcesContent":["import { AccessControlList, ACLFactory, AppPermission } from '@inrupt/solid-react-components';\nimport { errorToaster } from '@utils';\n\n// Check that all permissions we need are set. If any are missing, this returns false\nconst checkAppPermissions = (userAppPermissions, appPermissions) =>\n  appPermissions.every(permission => userAppPermissions.includes(permission));\n\n// Function to check for a specific permission included in the app\nexport const checkSpecificAppPermission = async (webId, permission) => {\n  const userAppPermissions = await AppPermission.checkPermissions(webId);\n  return userAppPermissions.permissions.includes(permission);\n};\n/**\n * SDK app will need all the permissions by the user pod so we check these permissions to work without any issues.\n * Error Message object is to hold the title, message, etc strings, as we can't use i18n libraries in this non-React file\n */\nexport const checkPermissions = async (webId, errorMessage) => {\n  /**\n   * Get permissions from trustedApp.\n   */\n  const userApp = await AppPermission.checkPermissions(webId);\n\n  /**\n   * Get modes permissions from solid-react-components\n   */\n  const permissions = AccessControlList.MODES;\n  const { APPEND, READ, WRITE, CONTROL } = permissions;\n\n  // If we are missing permissions that the app requires, display an error message with a Learn More link\n  if (\n    userApp === null ||\n    userApp.permissions === null ||\n    !checkAppPermissions(userApp.permissions, [APPEND, READ, WRITE, CONTROL])\n  ) {\n    errorToaster(errorMessage.message, errorMessage.title, {\n      label: errorMessage.label,\n      href: errorMessage.href\n    });\n  }\n};\n\n/**\n * Helper function to fetch permissions for the game inbox, and if permissions are not set\n * correctly, then add them. This repairs a broken inbox.\n * @param inboxPath\n * @returns {Promise<void>}\n */\nexport const checkOrSetInboxAppendPermissions = async (inboxPath, webId) => {\n  // Fetch app permissions for the inbox and see if Append is there\n  const inboxAcls = await ACLFactory.createNewAcl(webId, inboxPath);\n  const permissions = await inboxAcls.getPermissions();\n  const inboxPublicPermissions = permissions.filter(perm => perm.agents === null);\n\n  const appendPermission = inboxPublicPermissions.filter(perm =>\n    perm.modes.includes(AccessControlList.MODES.APPEND)\n  );\n\n  if (appendPermission.length <= 0) {\n    // What do we do when the permission is missing? Add it!\n    try {\n      // Permission object to add. A null agent means Everyone\n      const permissions = [\n        {\n          agents: null,\n          modes: [AccessControlList.MODES.APPEND]\n        }\n      ];\n      const ACLFile = await ACLFactory.createNewAcl(webId, inboxPath);\n      await ACLFile.createACL(permissions);\n    } catch (error) {\n      // TODO: Better error handling here\n      throw error;\n    }\n  }\n\n  return true;\n};\n"]},"metadata":{},"sourceType":"module"}