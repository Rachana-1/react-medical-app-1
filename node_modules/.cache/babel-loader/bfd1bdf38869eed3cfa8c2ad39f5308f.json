{"ast":null,"code":"/**\n *\n * isIRI, isBlank, getLiteralType, getLiteralValue\n */\nvar RdfTerm = function () {\n  var absoluteIRI = /^[a-z][a-z0-9+.-]*:/i,\n      schemeAuthority = /^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i,\n      dotSegments = /(?:^|\\/)\\.\\.?(?:$|[\\/#?])/;\n  var RdfLangString = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\";\n  var XsdString = \"http://www.w3.org/2001/XMLSchema#string\"; // N3.js:lib/N3Parser.js<0.4.5>:576 with\n  //   s/this\\./Parser./g\n  //   s/token/iri/\n  // ### `_resolveIRI` resolves a relative IRI token against the base path,\n  // assuming that a base path has been set and that the IRI is indeed relative.\n\n  function resolveRelativeIRI(base, iri) {\n    if (absoluteIRI.test(iri)) return iri;\n\n    switch (iri[0]) {\n      // An empty relative IRI indicates the base IRI\n      case undefined:\n        return base;\n      // Resolve relative fragment IRIs against the base IRI\n\n      case '#':\n        return base + iri;\n      // Resolve relative query string IRIs by replacing the query string\n\n      case '?':\n        return base.replace(/(?:\\?.*)?$/, iri);\n      // Resolve root-relative IRIs at the root of the base IRI\n\n      case '/':\n        var m = base.match(schemeAuthority); // Resolve scheme-relative IRIs to the scheme\n\n        return (iri[1] === '/' ? m[1] : m[0]) + _removeDotSegments(iri);\n      // Resolve all other IRIs at the base IRI's path\n\n      default:\n        {\n          return _removeDotSegments(base.replace(/[^\\/?]*(?:\\?.*)?$/, '') + iri);\n        }\n    }\n  } // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986.\n\n\n  function _removeDotSegments(iri) {\n    // Don't modify the IRI if it does not contain any dot segments\n    if (!dotSegments.test(iri)) return iri; // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n\n    var result = '',\n        length = iri.length,\n        i = -1,\n        pathStart = -1,\n        segmentStart = 0,\n        next = '/';\n\n    while (i < length) {\n      switch (next) {\n        // The path starts with the first slash after the authority\n        case ':':\n          if (pathStart < 0) {\n            // Skip two slashes before the authority\n            if (iri[++i] === '/' && iri[++i] === '/') // Skip to slash after the authority\n              while ((pathStart = i + 1) < length && iri[pathStart] !== '/') {\n                i = pathStart;\n              }\n          }\n\n          break;\n        // Don't modify a query string or fragment\n\n        case '?':\n        case '#':\n          i = length;\n          break;\n        // Handle '/.' or '/..' path segments\n\n        case '/':\n          if (iri[i + 1] === '.') {\n            next = iri[++i + 1];\n\n            switch (next) {\n              // Remove a '/.' segment\n              case '/':\n                result += iri.substring(segmentStart, i - 1);\n                segmentStart = i + 1;\n                break;\n              // Remove a trailing '/.' segment\n\n              case undefined:\n              case '?':\n              case '#':\n                return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n              // Remove a '/..' segment\n\n              case '.':\n                next = iri[++i + 1];\n\n                if (next === undefined || next === '/' || next === '?' || next === '#') {\n                  result += iri.substring(segmentStart, i - 2); // Try to remove the parent path from result\n\n                  if ((segmentStart = result.lastIndexOf('/')) >= pathStart) result = result.substr(0, segmentStart); // Remove a trailing '/..' segment\n\n                  if (next !== '/') return result + '/' + iri.substr(i + 1);\n                  segmentStart = i + 1;\n                }\n\n            }\n          }\n\n      }\n\n      next = iri[++i];\n    }\n\n    return result + iri.substring(segmentStart);\n  }\n\n  function internalTerm(node) {\n    // !!rdfjsTermToInternal\n    switch (node.termType) {\n      case \"NamedNode\":\n        return node.value;\n\n      case \"BlankNode\":\n        return \"_:\" + node.value;\n\n      case \"Literal\":\n        return \"\\\"\" + node.value + \"\\\"\" + (node.datatypeString === RdfLangString ? \"@\" + node.language : node.datatypeString === XsdString ? \"\" : \"^^\" + node.datatypeString);\n\n      default:\n        throw Error(\"unknown RDFJS node type: \" + JSON.stringify(node));\n    }\n  }\n\n  function internalTriple(triple) {\n    // !!rdfjsTripleToInternal\n    return {\n      subject: internalTerm(triple.subject),\n      predicate: internalTerm(triple.predicate),\n      object: internalTerm(triple.object)\n    };\n  }\n\n  function externalTerm(node, factory) {\n    // !!intermalTermToRdfjs\n    if (isIRI(node)) {\n      return factory.namedNode(node);\n    } else if (isBlank(node)) {\n      return factory.blankNode(node.substr(2));\n    } else if (isLiteral(node)) {\n      var dtOrLang = getLiteralLanguage(node) || (getLiteralType(node) === XsdString ? null // seems to screw up N3.js\n      : factory.namedNode(getLiteralType(node)));\n      return factory.literal(getLiteralValue(node), dtOrLang);\n    } else {\n      throw Error(\"Unknown internal term type: \" + JSON.stringify(node));\n    }\n  }\n\n  function externalTriple(triple, factory) {\n    // !!rename internalTripleToRdjs\n    return factory.quad(externalTerm(triple.subject, factory), externalTerm(triple.predicate, factory), externalTerm(triple.object, factory));\n  }\n\n  function intermalTermToTurtle(node, base, prefixes) {\n    if (isIRI(node)) {\n      // if (node === RDF_TYPE) // only valid in Turtle predicates\n      //   return \"a\";\n      // Escape special characters\n      if (escape.test(node)) node = node.replace(escapeAll, characterReplacer);\n      var pref = Object.keys(prefixes).find(function (pref) {\n        return node.startsWith(prefixes[pref]);\n      });\n\n      if (pref) {\n        var rest = node.substr(prefixes[pref].length);\n        if (rest.indexOf(\"\\\\\") === -1) // could also say no more than n of these: [...]\n          return pref + \":\" + rest.replace(/([~!$&'()*+,;=/?#@%])/g, '\\\\' + \"$1\");\n      }\n\n      if (node.startsWith(base)) {\n        return \"<\" + node.substr(base.length) + \">\";\n      } else {\n        return \"<\" + node + \">\";\n      }\n    } else if (isBlank(node)) {\n      return node;\n    } else if (isLiteral(node)) {\n      var value = getLiteralValue(node);\n      var type = getLiteralType(node);\n      var language = getLiteralLanguage(node); // Escape special characters\n\n      if (escape.test(value)) value = value.replace(escapeAll, characterReplacer); // Write the literal, possibly with type or language\n\n      if (language) return '\"' + value + '\"@' + language;else if (type) return '\"' + value + '\"^^' + this._encodeIriOrBlankNode(type);else return '\"' + value + '\"';\n    } else {\n      throw Error(\"Unknown internal term type: \" + JSON.stringify(node));\n    }\n  } // Tests whether the given entity (triple object) represents an IRI in the N3 library\n\n\n  function isIRI(entity) {\n    if (typeof entity !== 'string') return false;else if (entity.length === 0) return true;else {\n      var firstChar = entity[0];\n      return firstChar !== '\"' && firstChar !== '_';\n    }\n  } // Tests whether the given entity (triple object) represents a literal in the N3 library\n\n\n  function isLiteral(entity) {\n    return typeof entity === 'string' && entity[0] === '\"';\n  } // Tests whether the given entity (triple object) represents a blank node in the N3 library\n\n\n  function isBlank(entity) {\n    return typeof entity === 'string' && entity.substr(0, 2) === '_:';\n  } // Tests whether the given entity represents the default graph\n\n\n  function isDefaultGraph(entity) {\n    return !entity;\n  } // Tests whether the given triple is in the default graph\n\n\n  function inDefaultGraph(triple) {\n    return !triple.graph;\n  } // Gets the string value of a literal in the N3 library\n\n\n  function getLiteralValue(literal) {\n    var match = /^\"([^]*)\"/.exec(literal);\n    if (!match) throw new Error(literal + ' is not a literal');\n    return match[1];\n  } // Gets the type of a literal in the N3 library\n\n\n  function getLiteralType(literal) {\n    var match = /^\"[^]*\"(?:\\^\\^([^\"]+)|(@)[^@\"]+)?$/.exec(literal);\n    if (!match) throw new Error(literal + ' is not a literal');\n    return match[1] || (match[2] ? RdfLangString : XsdString);\n  } // Gets the language of a literal in the N3 library\n\n\n  function getLiteralLanguage(literal) {\n    var match = /^\"[^]*\"(?:@([^@\"]+)|\\^\\^[^\"]+)?$/.exec(literal);\n    if (!match) throw new Error(literal + ' is not a literal');\n    return match[1] ? match[1].toLowerCase() : '';\n  } // rdf:type predicate (for 'a' abbreviation)\n\n\n  var RDF_PREFIX = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n      RDF_TYPE = RDF_PREFIX + 'type'; // Characters in literals that require escaping\n\n  var escape = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n      escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n      escapeReplacements = {\n    '\\\\': '\\\\\\\\',\n    '\"': '\\\\\"',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\b': '\\\\b',\n    '\\f': '\\\\f'\n  }; // Replaces a character by its escaped version\n\n  function characterReplacer(character) {\n    // Replace a single character by its escaped version\n    var result = escapeReplacements[character];\n\n    if (result === undefined) {\n      // Replace a single character with its 4-bit unicode escape sequence\n      if (character.length === 1) {\n        result = character.charCodeAt(0).toString(16);\n        result = \"\\\\u0000\".substr(0, 6 - result.length) + result;\n      } // Replace a surrogate pair with its 8-bit unicode escape sequence\n      else {\n          result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);\n          result = \"\\\\U00000000\".substr(0, 10 - result.length) + result;\n        }\n    }\n\n    return result;\n  }\n\n  return {\n    RdfLangString: RdfLangString,\n    XsdString: XsdString,\n    resolveRelativeIRI: resolveRelativeIRI,\n    isIRI: isIRI,\n    isLiteral: isLiteral,\n    isBlank: isBlank,\n    isDefaultGraph: isDefaultGraph,\n    inDefaultGraph: inDefaultGraph,\n    getLiteralValue: getLiteralValue,\n    getLiteralType: getLiteralType,\n    getLiteralLanguage: getLiteralLanguage,\n    internalTerm: internalTerm,\n    internalTriple: internalTriple,\n    externalTerm: externalTerm,\n    externalTriple: externalTriple,\n    intermalTermToTurtle: intermalTermToTurtle\n  };\n}();\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') module.exports = RdfTerm; // node environment","map":null,"metadata":{},"sourceType":"script"}