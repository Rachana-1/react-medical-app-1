{"ast":null,"code":"var _defineProperty = require(\"D:\\\\Downloads\\\\Test HTML\\\\react-medical-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\n// **ShExUtil** provides ShEx utility functions\nvar ShExUtil = function () {\n  var _ShExUtil2;\n\n  var RdfTerm = require(\"./RdfTerm\"); // var util = require('util');\n\n\n  var Hierarchy = require('hierarchy-closure');\n\n  var SX = {};\n  SX._namespace = \"http://www.w3.org/ns/shex#\";\n  [\"Schema\", \"@context\", \"imports\", \"startActs\", \"start\", \"shapes\", \"ShapeDecl\", \"ShapeOr\", \"ShapeAnd\", \"shapeExprs\", \"nodeKind\", \"NodeConstraint\", \"iri\", \"bnode\", \"nonliteral\", \"literal\", \"datatype\", \"length\", \"minlength\", \"maxlength\", \"pattern\", \"flags\", \"mininclusive\", \"minexclusive\", \"maxinclusive\", \"maxexclusive\", \"totaldigits\", \"fractiondigits\", \"values\", \"ShapeNot\", \"shapeExpr\", \"Shape\", \"abstract\", \"closed\", \"extra\", \"expression\", \"extends\", \"restricts\", \"semActs\", \"ShapeRef\", \"reference\", \"ShapeExternal\", \"EachOf\", \"OneOf\", \"expressions\", \"min\", \"max\", \"annotation\", \"TripleConstraint\", \"inverse\", \"negated\", \"predicate\", \"valueExpr\", \"Inclusion\", \"include\", \"Language\", \"languageTag\", \"IriStem\", \"LiteralStem\", \"LanguageStem\", \"stem\", \"IriStemRange\", \"LiteralStemRange\", \"LanguageStemRange\", \"exclusion\", \"Wildcard\", \"SemAct\", \"name\", \"code\", \"Annotation\", \"object\"].forEach(function (p) {\n    SX[p] = SX._namespace + p;\n  });\n  var RDF = {};\n  RDF._namespace = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\";\n  [\"type\", \"first\", \"rest\", \"nil\"].forEach(function (p) {\n    RDF[p] = RDF._namespace + p;\n  });\n  var XSD = {};\n  XSD._namespace = \"http://www.w3.org/2001/XMLSchema#\";\n  [\"anyURI\"].forEach(function (p) {\n    XSD[p] = XSD._namespace + p;\n  });\n  var OWL = {};\n  OWL._namespace = \"http://www.w3.org/2002/07/owl#\";\n  [\"Thing\"].forEach(function (p) {\n    OWL[p] = OWL._namespace + p;\n  });\n  var Missed = {}; // singleton\n\n  var UNBOUNDED = -1;\n\n  function extend(base) {\n    if (!base) base = {};\n\n    for (var i = 1, l = arguments.length, arg; i < l && (arg = arguments[i] || {}); i++) {\n      for (var name in arg) {\n        base[name] = arg[name];\n      }\n    }\n\n    return base;\n  }\n\n  function isTerm(t) {\n    return typeof t !== \"object\" || \"value\" in t && Object.keys(t).reduce(function (r, k) {\n      return r === false ? r : [\"value\", \"type\", \"language\"].indexOf(k) !== -1;\n    }, true);\n  }\n\n  function isShapeRef(expr) {\n    return typeof expr === \"string\"; // test for JSON-LD @ID\n  }\n\n  var isInclusion = isShapeRef;\n  var ShExUtil = (_ShExUtil2 = {\n    SX: SX,\n    RDF: RDF,\n    version: function version() {\n      return \"0.5.0\";\n    },\n    Visitor: function Visitor() {\n      // function expect (l, r) { var ls = JSON.stringify(l), rs = JSON.stringify(r); if (ls !== rs) throw Error(ls+\" !== \"+rs); }\n      var _ShExUtil = this;\n\n      function visitMap(map, val) {\n        var ret = {};\n        Object.keys(map).forEach(function (item) {\n          ret[item] = val(map[item]);\n        });\n        return ret;\n      }\n\n      var r = {\n        runtimeError: function runtimeError(e) {\n          throw e;\n        },\n        visitSchema: function visitSchema(schema) {\n          var ret = {\n            type: \"Schema\"\n          };\n\n          _ShExUtil._expect(schema, \"type\", \"Schema\");\n\n          this._maybeSet(schema, ret, \"Schema\", [\"@context\", \"prefixes\", \"base\", \"imports\", \"startActs\", \"start\", \"shapes\"], [\"_base\", \"_prefixes\", \"_index\", \"_sourceMap\"]);\n\n          return ret;\n        },\n        visitPrefixes: function visitPrefixes(prefixes) {\n          return prefixes === undefined ? undefined : visitMap(prefixes, function (val) {\n            return val;\n          });\n        },\n        visitIRI: function visitIRI(i) {\n          return i;\n        },\n        visitImports: function visitImports(imports) {\n          var _Visitor = this;\n\n          return imports.map(function (imp) {\n            return _Visitor.visitIRI(imp);\n          });\n        },\n        visitStartActs: function visitStartActs(startActs) {\n          var _Visitor = this;\n\n          return startActs === undefined ? undefined : startActs.map(function (act) {\n            return _Visitor.visitSemAct(act);\n          });\n        },\n        visitSemActs: function visitSemActs(semActs) {\n          var _Visitor = this;\n\n          if (semActs === undefined) return undefined;\n          var ret = [];\n          Object.keys(semActs).forEach(function (label) {\n            ret.push(_Visitor.visitSemAct(semActs[label], label));\n          });\n          return ret;\n        },\n        visitSemAct: function visitSemAct(semAct, label) {\n          var ret = {\n            type: \"SemAct\"\n          };\n\n          _ShExUtil._expect(semAct, \"type\", \"SemAct\");\n\n          this._maybeSet(semAct, ret, \"SemAct\", [\"name\", \"code\"]);\n\n          return ret;\n        },\n        visitShapes: function visitShapes(shapes) {\n          var _Visitor = this;\n\n          if (shapes === undefined) return undefined;\n          return shapes.map(function (shapeExpr) {\n            return _Visitor.visitShapeDecl(shapeExpr);\n          });\n        },\n        visitProductions999: function visitProductions999(productions) {\n          // !! DELETE\n          var _Visitor = this;\n\n          if (productions === undefined) return undefined;\n          var ret = {};\n          Object.keys(productions).forEach(function (label) {\n            ret[label] = _Visitor.visitExpression(productions[label], label);\n          });\n          return ret;\n        },\n        visitShapeDecl: function visitShapeDecl(decl, label) {\n          return decl.type === \"ShapeDecl\" ? this._maybeSet(decl, {\n            type: \"ShapeDecl\"\n          }, \"ShapeDecl\", [\"id\", \"abstract\", \"restricts\", \"shapeExpr\"]) : this.visitShapeExpr(decl, label);\n        },\n        visitShapeExpr: function visitShapeExpr(expr, label) {\n          if (isShapeRef(expr)) return this.visitShapeRef(expr);\n          var r = expr.type === \"Shape\" ? this.visitShape(expr, label) : expr.type === \"NodeConstraint\" ? this.visitNodeConstraint(expr, label) : expr.type === \"ShapeAnd\" ? this.visitShapeAnd(expr, label) : expr.type === \"ShapeOr\" ? this.visitShapeOr(expr, label) : expr.type === \"ShapeNot\" ? this.visitShapeNot(expr, label) : expr.type === \"ShapeExternal\" ? this.visitShapeExternal(expr) : null; // if (expr.type === \"ShapeRef\") r = 0; // console.warn(\"visitShapeExpr:\", r);\n\n          if (r === null) throw Error(\"unexpected shapeExpr type: \" + expr.type);else return r;\n        },\n        // _visitShapeGroup: visit a grouping expression (shapeAnd, shapeOr)\n        _visitShapeGroup: function _visitShapeGroup(expr, label) {\n          this._testUnknownAttributes(expr, [\"id\", \"shapeExprs\"], expr.type, this.visitShapeNot);\n\n          var _Visitor = this;\n\n          var r = {\n            type: expr.type\n          };\n          if (\"id\" in expr) r.id = expr.id;\n          r.shapeExprs = expr.shapeExprs.map(function (nested) {\n            return _Visitor.visitShapeExpr(nested, label);\n          });\n          return r;\n        },\n        // _visitShapeNot: visit negated shape\n        visitShapeNot: function visitShapeNot(expr, label) {\n          this._testUnknownAttributes(expr, [\"id\", \"shapeExpr\"], \"ShapeNot\", this.visitShapeNot);\n\n          var r = {\n            type: expr.type\n          };\n          if (\"id\" in expr) r.id = expr.id;\n          r.shapeExpr = this.visitShapeExpr(expr.shapeExpr, label);\n          return r;\n        },\n        // ### `visitNodeConstraint` deep-copies the structure of a shape\n        visitShape: function visitShape(shape, label) {\n          var ret = {\n            type: \"Shape\"\n          };\n\n          _ShExUtil._expect(shape, \"type\", \"Shape\");\n\n          this._maybeSet(shape, ret, \"Shape\", [\"id\", \"abstract\", \"extends\", \"closed\", \"expression\", \"extra\", \"semActs\", \"annotations\"]);\n\n          return ret;\n        },\n        _visitShapeExprList: function _visitShapeExprList(ext) {\n          var _Visitor = this;\n\n          return ext.map(function (t) {\n            return _Visitor.visitShapeExpr(t, undefined);\n          });\n        },\n        // ### `visitNodeConstraint` deep-copies the structure of a shape\n        visitNodeConstraint: function visitNodeConstraint(shape, label) {\n          var ret = {\n            type: \"NodeConstraint\"\n          };\n\n          _ShExUtil._expect(shape, \"type\", \"NodeConstraint\");\n\n          this._maybeSet(shape, ret, \"NodeConstraint\", [\"id\", // \"abstract\", \"extends\", \"restricts\", -- futureWork\n          \"nodeKind\", \"datatype\", \"pattern\", \"flags\", \"length\", \"reference\", \"minlength\", \"maxlength\", \"mininclusive\", \"minexclusive\", \"maxinclusive\", \"maxexclusive\", \"totaldigits\", \"fractiondigits\", \"values\", \"annotations\", \"semActs\"]);\n\n          return ret;\n        },\n        visitShapeRef: function visitShapeRef(reference) {\n          if (typeof reference !== \"string\") {\n            var ex = Exception(\"visitShapeRef expected a string, not \" + JSON.stringify(reference));\n            console.warn(ex);\n            throw ex;\n          }\n\n          return reference;\n        },\n        visitShapeExternal: function visitShapeExternal(expr) {\n          this._testUnknownAttributes(expr, [\"id\"], \"ShapeExternal\", this.visitShapeNot);\n\n          return extend(\"id\" in expr ? {\n            id: expr.id\n          } : {}, {\n            type: \"ShapeExternal\"\n          });\n        },\n        // _visitGroup: visit a grouping expression (someOf or eachOf)\n        _visitGroup: function _visitGroup(expr, type) {\n          var _Visitor = this;\n\n          var r = Object.assign( // pre-declare an id so it sorts to the top\n          \"id\" in expr ? {\n            id: null\n          } : {}, {\n            type: expr.type\n          });\n          r.expressions = expr.expressions.map(function (nested) {\n            return _Visitor.visitExpression(nested);\n          });\n          return this._maybeSet(expr, r, \"expr\", [\"id\", \"min\", \"max\", \"onShapeExpression\", \"annotations\", \"semActs\"], [\"expressions\"]);\n        },\n        visitTripleConstraint: function visitTripleConstraint(expr) {\n          return this._maybeSet(expr, Object.assign( // pre-declare an id so it sorts to the top\n          \"id\" in expr ? {\n            id: null\n          } : {}, {\n            type: \"TripleConstraint\"\n          }), \"TripleConstraint\", [\"id\", \"inverse\", \"predicate\", \"valueExpr\", \"min\", \"max\", \"onShapeExpression\", \"annotations\", \"semActs\"]);\n        },\n        visitExpression: function visitExpression(expr) {\n          if (typeof expr === \"string\") return this.visitInclusion(expr);\n          var r = expr.type === \"TripleConstraint\" ? this.visitTripleConstraint(expr) : expr.type === \"OneOf\" ? this.visitOneOf(expr) : expr.type === \"EachOf\" ? this.visitEachOf(expr) : null;\n          if (r === null) throw Error(\"unexpected expression type: \" + expr.type);else return r;\n        },\n        visitValues: function visitValues(values) {\n          var _Visitor = this;\n\n          return values.map(function (t) {\n            return isTerm(t) || t.type === \"Language\" ? t : _Visitor.visitStemRange(t);\n          });\n        },\n        visitStemRange: function visitStemRange(t) {\n          var _Visitor = this; // console.log(Error(t.type).stack);\n          // _ShExUtil._expect(t, \"type\", \"IriStemRange\");\n\n\n          if (!(\"type\" in t)) _Visitor.runtimeError(Error(\"expected \" + JSON.stringify(t) + \" to have a 'type' attribute.\"));\n          var stemRangeTypes = [\"IriStem\", \"LiteralStem\", \"LanguageStem\", \"IriStemRange\", \"LiteralStemRange\", \"LanguageStemRange\"];\n          if (stemRangeTypes.indexOf(t.type) === -1) _Visitor.runtimeError(Error(\"expected type attribute '\" + t.type + \"' to be in '\" + stemRangeTypes + \"'.\"));\n          var stem;\n\n          if (isTerm(t)) {\n            _ShExUtil._expect(t.stem, \"type\", \"Wildcard\");\n\n            stem = {\n              type: t.type,\n              stem: {\n                type: \"Wildcard\"\n              }\n            };\n          } else {\n            stem = {\n              type: t.type,\n              stem: t.stem\n            };\n          }\n\n          if (t.exclusions) {\n            stem.exclusions = t.exclusions.map(function (c) {\n              return _Visitor.visitExclusion(c);\n            });\n          }\n\n          return stem;\n        },\n        visitExclusion: function visitExclusion(c) {\n          if (!isTerm(c)) {\n            // _ShExUtil._expect(c, \"type\", \"IriStem\");\n            if (!(\"type\" in c)) _Visitor.runtimeError(Error(\"expected \" + JSON.stringify(c) + \" to have a 'type' attribute.\"));\n            var stemTypes = [\"IriStem\", \"LiteralStem\", \"LanguageStem\"];\n            if (stemTypes.indexOf(c.type) === -1) _Visitor.runtimeError(Error(\"expected type attribute '\" + c.type + \"' to be in '\" + stemTypes + \"'.\"));\n            return {\n              type: c.type,\n              stem: c.stem\n            };\n          } else {\n            return c;\n          }\n        },\n        visitInclusion: function visitInclusion(inclusion) {\n          if (typeof inclusion !== \"string\") {\n            var ex = Exception(\"visitInclusion expected a string, not \" + JSON.stringify(inclusion));\n            console.warn(ex);\n            throw ex;\n          }\n\n          return inclusion;\n        },\n        _maybeSet: function _maybeSet(obj, ret, context, members, ignore) {\n          var _Visitor = this;\n\n          this._testUnknownAttributes(obj, ignore ? members.concat(ignore) : members, context, this._maybeSet);\n\n          members.forEach(function (member) {\n            var methodName = \"visit\" + member.charAt(0).toUpperCase() + member.slice(1);\n\n            if (member in obj) {\n              var f = _Visitor[methodName];\n\n              if (typeof f !== \"function\") {\n                throw Error(methodName + \" not found in Visitor\");\n              }\n\n              var t = f.call(_Visitor, obj[member]);\n\n              if (t !== undefined) {\n                ret[member] = t;\n              }\n            }\n          });\n          return ret;\n        },\n        _visitValue: function _visitValue(v) {\n          return v;\n        },\n        _visitList: function _visitList(l) {\n          return l.slice();\n        },\n        _testUnknownAttributes: function _testUnknownAttributes(obj, expected, context, captureFrame) {\n          var unknownMembers = Object.keys(obj).reduce(function (ret, k) {\n            return k !== \"type\" && expected.indexOf(k) === -1 ? ret.concat(k) : ret;\n          }, []);\n\n          if (unknownMembers.length > 0) {\n            var e = Error(\"unknown propert\" + (unknownMembers.length > 1 ? \"ies\" : \"y\") + \": \" + unknownMembers.map(function (p) {\n              return \"\\\"\" + p + \"\\\"\";\n            }).join(\",\") + \" in \" + context + \": \" + JSON.stringify(obj));\n            Error.captureStackTrace(e, captureFrame);\n            throw e;\n          }\n        }\n      };\n      r.visitBase = r.visitStart = r.visitVirtual = r.visitClosed = r[\"visit@context\"] = r._visitValue;\n      r.visitRestricts = r.visitExtends = r._visitShapeExprList;\n      r.visitExtra = r.visitAnnotations = r._visitList;\n      r.visitAbstract = r.visitInverse = r.visitPredicate = r._visitValue;\n      r.visitName = r.visitId = r.visitCode = r.visitMin = r.visitMax = r._visitValue;\n      r.visitType = r.visitNodeKind = r.visitDatatype = r.visitPattern = r.visitFlags = r.visitLength = r.visitMinlength = r.visitMaxlength = r.visitMininclusive = r.visitMinexclusive = r.visitMaxinclusive = r.visitMaxexclusive = r.visitTotaldigits = r.visitFractiondigits = r._visitValue;\n      r.visitOneOf = r.visitEachOf = r._visitGroup;\n      r.visitShapeAnd = r.visitShapeOr = r._visitShapeGroup;\n      r.visitInclude = r._visitValue;\n      r.visitValueExpr = r.visitOnShapeExpression = r.visitShapeExpr;\n      return r;\n    },\n    // tests\n    // console.warn(\"HERE:\", ShExJtoAS({\"type\":\"Schema\",\"shapes\":[{\"id\":\"http://all.example/S1\",\"type\":\"Shape\",\"expression\":\n    //  { \"id\":\"http://all.example/S1e\", \"type\":\"EachOf\",\"expressions\":[ ] },\n    // // { \"id\":\"http://all.example/S1e\",\"type\":\"TripleConstraint\",\"predicate\":\"http://all.example/p1\"},\n    // \"extra\":[\"http://all.example/p3\",\"http://all.example/p1\",\"http://all.example/p2\"]\n    // }]}).shapes['http://all.example/S1']);\n    ShExJtoAS: function ShExJtoAS(schema) {\n      var _ShExUtil = this;\n\n      schema._prefixes = schema.prefixes || {};\n      schema._index = this.index(schema);\n      return schema;\n    },\n    AStoShExJ: function AStoShExJ(schema, abbreviate) {\n      schema[\"@context\"] = schema[\"@context\"] || \"http://www.w3.org/ns/shex.jsonld\";\n      delete schema[\"_index\"];\n      delete schema[\"_prefixes\"];\n      return schema;\n    },\n    ShExRVisitor: function ShExRVisitor(knownShapeExprs) {\n      var v = ShExUtil.Visitor();\n      var knownExpressions = {};\n      var oldVisitShapeExpr = v.visitShapeExpr,\n          oldVisitValueExpr = v.visitValueExpr,\n          oldVisitExpression = v.visitExpression;\n      v.keepShapeExpr = oldVisitShapeExpr;\n\n      v.visitShapeExpr = v.visitValueExpr = function (expr, label) {\n        if (typeof expr === \"string\") return expr;\n\n        if (\"id\" in expr) {\n          if (knownShapeExprs.indexOf(expr.id) !== -1 || Object.keys(expr).length === 1) return expr.id;\n          delete expr.id;\n        }\n\n        return oldVisitShapeExpr.call(this, expr, label);\n      };\n\n      v.visitExpression = function (expr) {\n        if (typeof expr === \"string\") // shortcut for recursive references e.g. 1Include1 and ../doc/TODO.md\n          return expr;\n\n        if (\"id\" in expr) {\n          if (expr.id in knownExpressions) {\n            knownExpressions[expr.id].refCount++;\n            return expr.id;\n          }\n        }\n\n        var ret = oldVisitExpression.call(this, expr); // Everything from RDF has an ID, usually a BNode.\n\n        knownExpressions[expr.id] = {\n          refCount: 1,\n          expr: ret\n        };\n        return ret;\n      };\n\n      v.cleanIds = function () {\n        for (var k in knownExpressions) {\n          var known = knownExpressions[k];\n          if (known.refCount === 1 && RdfTerm.isBlank(known.expr.id)) delete known.expr.id;\n        }\n\n        ;\n      };\n\n      return v;\n    },\n    // tests\n    // var shexr = ShExUtil.ShExRtoShExJ({ \"type\": \"Schema\", \"shapes\": [\n    //   { \"id\": \"http://a.example/S1\", \"type\": \"Shape\",\n    //     \"expression\": {\n    //       \"type\": \"TripleConstraint\", \"predicate\": \"http://a.example/p1\",\n    //       \"valueExpr\": {\n    //         \"type\": \"ShapeAnd\", \"shapeExprs\": [\n    //           { \"type\": \"NodeConstraint\", \"nodeKind\": \"bnode\" },\n    //           { \"id\": \"http://a.example/S2\", \"type\": \"Shape\",\n    //             \"expression\": {\n    //               \"type\": \"TripleConstraint\", \"predicate\": \"http://a.example/p2\" } }\n    //           //            \"http://a.example/S2\"\n    //         ] } } },\n    //   { \"id\": \"http://a.example/S2\", \"type\": \"Shape\",\n    //     \"expression\": {\n    //       \"type\": \"TripleConstraint\", \"predicate\": \"http://a.example/p2\" } }\n    // ] });\n    // console.warn(\"HERE:\", shexr.shapes[0].expression.valueExpr);\n    // ShExUtil.ShExJtoAS(shexr);\n    // console.warn(\"THERE:\", shexr.shapes[\"http://a.example/S1\"].expression.valueExpr);\n    ShExRtoShExJ: function ShExRtoShExJ(schema) {\n      // compile a list of known shapeExprs\n      var knownShapeExprs = [];\n      if (\"shapes\" in schema) knownShapeExprs = knownShapeExprs.concat(schema.shapes.map(function (sh) {\n        return sh.id;\n      })); // normalize references to those shapeExprs\n\n      var v = this.ShExRVisitor(knownShapeExprs);\n      if (\"start\" in schema) schema.start = v.visitShapeExpr(schema.start);\n      if (\"shapes\" in schema) schema.shapes = schema.shapes.map(function (sh) {\n        return sh.type === SX.ShapeDecl ? {\n          type: \"ShapeDecl\",\n          id: sh.id,\n          abstract: sh.abstract,\n          shapeExpr: v.visitShapeExpr(sh.shapeExpr)\n        } : v.keepShapeExpr(sh);\n      }); // remove extraneous BNode IDs\n\n      v.cleanIds();\n      return schema;\n    },\n    valGrep: function valGrep(obj, type, f) {\n      var _ShExUtil = this;\n\n      var ret = [];\n\n      for (var i in obj) {\n        var o = obj[i];\n\n        if (typeof o === \"object\") {\n          if (\"type\" in o && o.type === type) ret.push(f(o));\n          ret.push.apply(ret, _ShExUtil.valGrep(o, type, f));\n        }\n      }\n\n      return ret;\n    },\n    n3jsToTurtle: function n3jsToTurtle(res) {\n      function termToLex(node) {\n        return typeof node === \"object\" ? \"\\\"\" + node.value + \"\\\"\" + (\"type\" in node ? \"^^<\" + node.type + \">\" : \"language\" in node ? \"@\" + node.language : \"\") : RdfTerm.isIRI(node) ? \"<\" + node + \">\" : RdfTerm.isBlank(node) ? node : \"???\";\n      }\n\n      return this.valGrep(res, \"TestedTriple\", function (t) {\n        return [\"subject\", \"predicate\", \"object\"].map(function (k) {\n          return termToLex(t[k]);\n        }).join(\" \") + \" .\";\n      });\n    },\n    valToN3js: function valToN3js(res) {\n      return this.valGrep(res, \"TestedTriple\", function (t) {\n        var ret = JSON.parse(JSON.stringify(t));\n        if (typeof t.object === \"object\") ret.object = \"\\\"\" + t.object.value + \"\\\"\" + (\"type\" in t.object ? \"^^\" + t.object.type : \"language\" in t.object ? \"@\" + t.object.language : \"\");\n        return ret;\n      });\n    }\n  }, _defineProperty(_ShExUtil2, \"n3jsToTurtle\", function n3jsToTurtle(n3js) {\n    function termToLex(node) {\n      if (RdfTerm.isIRI(node)) return \"<\" + node + \">\";\n      if (RdfTerm.isBlank(node)) return node;\n      var t = RdfTerm.getLiteralType(node);\n      if (t && t !== \"http://www.w3.org/2001/XMLSchema#string\") return \"\\\"\" + RdfTerm.getLiteralValue(node) + \"\\\"\" + \"^^<\" + t + \">\";\n      return node;\n    }\n\n    return n3js.map(function (t) {\n      return [\"subject\", \"predicate\", \"object\"].map(function (k) {\n        return termToLex(t[k]);\n      }).join(\" \") + \" .\";\n    });\n  }), _defineProperty(_ShExUtil2, \"index\", function index(schema) {\n    var index = {\n      shapeExprs: {},\n      tripleExprs: {}\n    };\n    var v = ShExUtil.Visitor();\n    var oldVisitExpression = v.visitExpression;\n\n    v.visitExpression = function (expression) {\n      if (typeof expression === \"object\" && \"id\" in expression) index.tripleExprs[expression.id] = expression;\n      return oldVisitExpression.call(v, expression);\n    };\n\n    var oldVisitShapeExpr = v.visitShapeExpr;\n\n    v.visitShapeExpr = v.visitValueExpr = function (shapeExpr, label) {\n      if (typeof shapeExpr === \"object\" && \"id\" in shapeExpr) index.shapeExprs[shapeExpr.id] = shapeExpr;\n      return oldVisitShapeExpr.call(v, shapeExpr, label);\n    };\n\n    var oldVisitShapeDecl = v.visitShapeDecl;\n\n    v.visitShapeDecl = v.visitValueExpr = function (shapeExpr, label) {\n      if (typeof shapeExpr === \"object\" && \"id\" in shapeExpr) index.shapeExprs[shapeExpr.id] = shapeExpr;\n      return oldVisitShapeDecl.call(v, shapeExpr, label);\n    };\n\n    v.visitSchema(schema);\n    return index;\n  }), _defineProperty(_ShExUtil2, \"canonicalize\", function canonicalize(schema, trimIRI) {\n    var ret = JSON.parse(JSON.stringify(schema));\n    ret[\"@context\"] = ret[\"@context\"] || \"http://www.w3.org/ns/shex.jsonld\";\n    delete ret._prefixes;\n    delete ret._base;\n    var index = ret._index || this.index(schema);\n    delete ret._index;\n    var sourceMap = ret._sourceMap;\n    delete ret._sourceMap; // Don't delete ret.productions as it's part of the AS.\n\n    var v = ShExUtil.Visitor();\n    var knownExpressions = [];\n    var oldVisitInclusion = v.visitInclusion,\n        oldVisitExpression = v.visitExpression;\n\n    v.visitInclusion = function (inclusion) {\n      if (knownExpressions.indexOf(inclusion) === -1 && inclusion in index.tripleExprs) {\n        knownExpressions.push(inclusion);\n        return oldVisitExpression.call(v, index.tripleExprs[inclusion]);\n      }\n\n      return oldVisitInclusion.call(v, inclusion);\n    };\n\n    v.visitExpression = function (expression) {\n      if (typeof expression === \"object\" && \"id\" in expression) {\n        if (knownExpressions.indexOf(expression.id) === -1) {\n          knownExpressions.push(expression.id);\n          return oldVisitExpression.call(v, index.tripleExprs[expression.id]);\n        }\n\n        return expression.id; // Inclusion\n      }\n\n      return oldVisitExpression.call(v, expression);\n    };\n\n    if (trimIRI) {\n      v.visitIRI = function (i) {\n        return i.replace(trimIRI, \"\");\n      };\n\n      if (\"imports\" in ret) ret.imports = v.visitImports(ret.imports);\n    }\n\n    if (\"shapes\" in ret) {\n      ret.shapes = Object.keys(index.shapeExprs).sort().map(function (k) {\n        if (\"extra\" in index.shapeExprs[k]) index.shapeExprs[k].extra.sort();\n        return v.visitShapeDecl(index.shapeExprs[k]);\n      });\n    }\n\n    return ret;\n  }), _defineProperty(_ShExUtil2, \"BiDiClosure\", function BiDiClosure() {\n    return {\n      needs: {},\n      neededBy: {},\n      inCycle: [],\n      test: function test() {\n        function expect(l, r) {\n          var ls = JSON.stringify(l),\n              rs = JSON.stringify(r);\n          if (ls !== rs) throw Error(ls + \" !== \" + rs);\n        } // this.add(1, 2); expect(this.needs, { 1:[2]                     }); expect(this.neededBy, { 2:[1]                     });\n        // this.add(3, 4); expect(this.needs, { 1:[2], 3:[4]              }); expect(this.neededBy, { 2:[1], 4:[3]              });\n        // this.add(2, 3); expect(this.needs, { 1:[2,3,4], 2:[3,4], 3:[4] }); expect(this.neededBy, { 2:[1], 3:[2,1], 4:[3,2,1] });\n\n\n        this.add(2, 3);\n        expect(this.needs, {\n          2: [3]\n        });\n        expect(this.neededBy, {\n          3: [2]\n        });\n        this.add(1, 2);\n        expect(this.needs, {\n          1: [2, 3],\n          2: [3]\n        });\n        expect(this.neededBy, {\n          3: [2, 1],\n          2: [1]\n        });\n        this.add(1, 3);\n        expect(this.needs, {\n          1: [2, 3],\n          2: [3]\n        });\n        expect(this.neededBy, {\n          3: [2, 1],\n          2: [1]\n        });\n        this.add(3, 4);\n        expect(this.needs, {\n          1: [2, 3, 4],\n          2: [3, 4],\n          3: [4]\n        });\n        expect(this.neededBy, {\n          3: [2, 1],\n          2: [1],\n          4: [3, 2, 1]\n        });\n        this.add(6, 7);\n        expect(this.needs, {\n          6: [7],\n          1: [2, 3, 4],\n          2: [3, 4],\n          3: [4]\n        });\n        expect(this.neededBy, {\n          7: [6],\n          3: [2, 1],\n          2: [1],\n          4: [3, 2, 1]\n        });\n        this.add(5, 6);\n        expect(this.needs, {\n          5: [6, 7],\n          6: [7],\n          1: [2, 3, 4],\n          2: [3, 4],\n          3: [4]\n        });\n        expect(this.neededBy, {\n          7: [6, 5],\n          6: [5],\n          3: [2, 1],\n          2: [1],\n          4: [3, 2, 1]\n        });\n        this.add(5, 7);\n        expect(this.needs, {\n          5: [6, 7],\n          6: [7],\n          1: [2, 3, 4],\n          2: [3, 4],\n          3: [4]\n        });\n        expect(this.neededBy, {\n          7: [6, 5],\n          6: [5],\n          3: [2, 1],\n          2: [1],\n          4: [3, 2, 1]\n        });\n        this.add(7, 8);\n        expect(this.needs, {\n          5: [6, 7, 8],\n          6: [7, 8],\n          7: [8],\n          1: [2, 3, 4],\n          2: [3, 4],\n          3: [4]\n        });\n        expect(this.neededBy, {\n          7: [6, 5],\n          6: [5],\n          8: [7, 6, 5],\n          3: [2, 1],\n          2: [1],\n          4: [3, 2, 1]\n        });\n        this.add(4, 5);\n        expect(this.needs, {\n          1: [2, 3, 4, 5, 6, 7, 8],\n          2: [3, 4, 5, 6, 7, 8],\n          3: [4, 5, 6, 7, 8],\n          4: [5, 6, 7, 8],\n          5: [6, 7, 8],\n          6: [7, 8],\n          7: [8]\n        });\n        expect(this.neededBy, {\n          2: [1],\n          3: [2, 1],\n          4: [3, 2, 1],\n          5: [4, 3, 2, 1],\n          6: [5, 4, 3, 2, 1],\n          7: [6, 5, 4, 3, 2, 1],\n          8: [7, 6, 5, 4, 3, 2, 1]\n        });\n      },\n      add: function add(needer, needie, negated) {\n        var r = this;\n        if (!(needer in r.needs)) r.needs[needer] = [];\n        if (!(needie in r.neededBy)) r.neededBy[needie] = []; // // [].concat.apply(r.needs[needer], [needie], r.needs[needie]). emitted only last element\n\n        r.needs[needer] = r.needs[needer].concat([needie], r.needs[needie]).filter(function (el, ord, l) {\n          return el !== undefined && l.indexOf(el) === ord;\n        }); // // [].concat.apply(r.neededBy[needie], [needer], r.neededBy[needer]). emitted only last element\n\n        r.neededBy[needie] = r.neededBy[needie].concat([needer], r.neededBy[needer]).filter(function (el, ord, l) {\n          return el !== undefined && l.indexOf(el) === ord;\n        });\n        if (needer in this.neededBy) this.neededBy[needer].forEach(function (e) {\n          r.needs[e] = r.needs[e].concat([needie], r.needs[needie]).filter(function (el, ord, l) {\n            return el !== undefined && l.indexOf(el) === ord;\n          });\n        });\n        if (needie in this.needs) this.needs[needie].forEach(function (e) {\n          r.neededBy[e] = r.neededBy[e].concat([needer], r.neededBy[needer]).filter(function (el, ord, l) {\n            return el !== undefined && l.indexOf(el) === ord;\n          });\n        }); // this.neededBy[needie].push(needer);\n\n        if (r.needs[needer].indexOf(needer) !== -1) r.inCycle = r.inCycle.concat(r.needs[needer]);\n      },\n      trim: function trim() {\n        function _trim(a) {\n          // filter(function (el, ord, l) { return l.indexOf(el) === ord; })\n          for (var i = a.length - 1; i > -1; --i) {\n            if (a.indexOf(a[i]) < i) a.splice(i, i + 1);\n          }\n        }\n\n        for (k in this.needs) {\n          _trim(this.needs[k]);\n        }\n\n        for (k in this.neededBy) {\n          _trim(this.neededBy[k]);\n        }\n      },\n      foundIn: {},\n      addIn: function addIn(tripleExpr, shapeExpr) {\n        this.foundIn[tripleExpr] = shapeExpr;\n      }\n    };\n  }), _defineProperty(_ShExUtil2, \"nestShapes\", function nestShapes(schema) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _ShExUtil = this;\n\n    var index = schema._index || this.index(schema);\n\n    if (!('no' in options)) {\n      options.no = false;\n    }\n\n    var shapeLabels = Object.keys(index.shapeExprs || []);\n    var shapeReferences = {};\n    shapeLabels.forEach(function (label) {\n      var shape = index.shapeExprs[label];\n      noteReference(label, null); // just note the shape so we have a complete list at the end\n\n      shape = _ShExUtil.skipDecl(shape);\n\n      if (shape.type === 'Shape') {\n        if ('extends' in shape) {\n          shape.extends.forEach( // !!! assumes simple reference, not e.g. AND\n          function (parent) {\n            return noteReference(parent, shape);\n          });\n        }\n\n        if ('expression' in shape) {\n          (_ShExUtil.simpleTripleConstraints(shape) || []).forEach(function (tc) {\n            var target = _ShExUtil.getValueType(tc.valueExpr, true);\n\n            noteReference(target, {\n              type: 'tc',\n              shapeLabel: label,\n              tc: tc\n            });\n          });\n        }\n      } else if (shape.type === 'NodeConstraint') {// can't have any refs to other shapes\n      } else {\n        throw Error('nestShapes currently only supports Shapes and NodeConstraints');\n      }\n    });\n    var nestables = Object.keys(shapeReferences).filter(function (label) {\n      return shapeReferences[label].length === 1 && shapeReferences[label][0].type === 'tc' // no inheritance support yet\n      && _ShExUtil.skipDecl(index.shapeExprs[label]).type === 'Shape';\n    } // Don't nest e.g. valuesets for now\n    ).filter(function (nestable) {\n      return !('noNestPattern' in options) || !nestable.match(RegExp(options.noNestPattern));\n    }).reduce(function (acc, label) {\n      acc[label] = {\n        referrer: shapeReferences[label][0].shapeLabel,\n        predicate: shapeReferences[label][0].tc.predicate\n      };\n      return acc;\n    }, {});\n\n    if (!options.no) {\n      var oldToNew = {};\n\n      if (options.rename) {\n        if (!('transform' in options)) {\n          options.transform = function () {\n            var map = shapeLabels.reduce(function (acc, k, idx) {\n              acc[k] = '_:transformed' + idx;\n              return acc;\n            }, {});\n            return function (id, shapeExpr) {\n              return map[id];\n            };\n          }();\n        }\n\n        Object.keys(nestables).forEach(function (oldName) {\n          var shapeExpr = index.shapeExprs[oldName];\n          var newName = options.transform(oldName, shapeExpr);\n          oldToNew[oldName] = newName;\n          shapeLabels[shapeLabels.indexOf(oldName)] = newName;\n          nestables[newName] = nestables[oldName];\n          nestables[newName].was = oldName;\n          delete nestables[oldName];\n          index.shapeExprs[newName] = index.shapeExprs[oldName];\n          delete index.shapeExprs[oldName];\n\n          if (shapeReferences[oldName].length !== 1) {\n            throw Error('assertion: ' + oldName + ' doesn\\'t have one reference: [' + shapeReferences[oldName] + ']');\n          }\n\n          var ref = shapeReferences[oldName][0];\n\n          if (ref.type === 'tc') {\n            if (ref.tc.valueExpr.type === 'ShapeRef') {\n              ref.tc.valueExpr.reference = newName;\n            } else {\n              throw Error('assertion: rename not implemented for TripleConstraint expr: ' + ref.tc.valueExpr); // _ShExUtil.setValueType(ref, newName)\n            }\n          } else if (ref.type === 'Shape') {\n            throw Error('assertion: rename not implemented for Shape: ' + ref);\n          } else {\n            throw Error('assertion: ' + ref.type + ' not TripleConstraint or Shape');\n          }\n        });\n        Object.keys(nestables).forEach(function (k) {\n          var n = nestables[k];\n\n          if (n.referrer in oldToNew) {\n            n.newReferrer = oldToNew[n.referrer];\n          }\n        }); // Restore old order for more concise diffs.\n\n        var shapesCopy = {};\n        shapeLabels.forEach(function (label) {\n          return shapesCopy[label] = index.shapeExprs[label];\n        });\n        index.shapeExprs = shapesCopy;\n      } else {\n        var doomed = [];\n        var ids = schema.shapes.map(function (s) {\n          return s.id;\n        });\n        Object.keys(nestables).forEach(function (oldName) {\n          shapeReferences[oldName][0].tc.valueExpr = index.shapeExprs[oldName].shapeExpr;\n          var delme = ids.indexOf(oldName);\n          if (schema.shapes[delme].id !== oldName) throw Error('assertion: found ' + schema.shapes[delme].id + ' instead of ' + oldName);\n          doomed.push(delme);\n          delete index.shapeExprs[oldName];\n        });\n        doomed.sort(function (l, r) {\n          return r - l;\n        }).forEach(function (delme) {\n          var id = schema.shapes[delme].id;\n          if (!nestables[id]) throw Error('deleting unexpected shape ' + id);\n          schema.shapes.splice(delme, 1);\n        });\n      }\n    } // console.dir(nestables)\n    // console.dir(shapeReferences)\n\n\n    return nestables;\n\n    function noteReference(id, reference) {\n      if (!(id in shapeReferences)) {\n        shapeReferences[id] = [];\n      }\n\n      if (reference) {\n        shapeReferences[id].push(reference);\n      }\n    }\n  }), _defineProperty(_ShExUtil2, \"getPredicateUsage\", function getPredicateUsage(schema) {\n    var untyped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _ShExUtil = this; // populate shapeHierarchy\n\n\n    var shapeHierarchy = Hierarchy.create();\n    Object.keys(schema.shapes).forEach(function (label) {\n      var shapeExpr = _ShExUtil.skipDecl(schema.shapes[label]);\n\n      if (shapeExpr.type === 'Shape') {\n        (shapeExpr.extends || []).forEach(function (superShape) {\n          return shapeHierarchy.add(superShape.reference, label);\n        });\n      }\n    });\n    Object.keys(schema.shapes).forEach(function (label) {\n      if (!(label in shapeHierarchy.parents)) shapeHierarchy.parents[label] = [];\n    });\n    var predicates = {}; // IRI->{ uses: [shapeLabel], commonType: shapeExpr }\n\n    Object.keys(schema.shapes).forEach(function (shapeLabel) {\n      var shapeExpr = _ShExUtil.skipDecl(schema.shapes[shapeLabel]);\n\n      if (shapeExpr.type === 'Shape') {\n        var tcs = _ShExUtil.simpleTripleConstraints(shapeExpr) || [];\n        tcs.forEach(function (tc) {\n          var newType = _ShExUtil.getValueType(tc.valueExpr);\n\n          if (!(tc.predicate in predicates)) {\n            predicates[tc.predicate] = {\n              uses: [shapeLabel],\n              commonType: newType,\n              polymorphic: false\n            };\n\n            if (typeof newType === 'object') {\n              untyped[tc.predicate] = {\n                shapeLabel: shapeLabel,\n                predicate: tc.predicate,\n                newType: newType,\n                references: []\n              };\n            }\n          } else {\n            predicates[tc.predicate].uses.push(shapeLabel);\n            var curType = predicates[tc.predicate].commonType;\n\n            if (typeof curType === 'object' || curType === null) {\n              // another use of a predicate with no commonType\n              // console.warn(`${shapeLabel} ${tc.predicate}:${newType} uses untypable predicate`)\n              untyped[tc.predicate].references.push({\n                shapeLabel: shapeLabel,\n                newType: newType\n              });\n            } else if (typeof newType === 'object') {\n              // first use of a predicate with no detectable commonType\n              predicates[tc.predicate].commonType = null;\n              untyped[tc.predicate] = {\n                shapeLabel: shapeLabel,\n                predicate: tc.predicate,\n                curType: curType,\n                newType: newType,\n                references: []\n              };\n            } else if (curType === newType) {\n              ; // same type again\n            } else if (shapeHierarchy.parents[curType] && shapeHierarchy.parents[curType].indexOf(newType) !== -1) {\n              predicates[tc.predicate].polymorphic = true; // already covered by current commonType\n            } else {\n              var idx = shapeHierarchy.parents[newType] ? shapeHierarchy.parents[newType].indexOf(curType) : -1;\n\n              if (idx === -1) {\n                var intersection = shapeHierarchy.parents[curType] ? shapeHierarchy.parents[curType].filter(function (lab) {\n                  return -1 !== shapeHierarchy.parents[newType].indexOf(lab);\n                }) : [];\n\n                if (intersection.length === 0) {\n                  untyped[tc.predicate] = {\n                    shapeLabel: shapeLabel,\n                    predicate: tc.predicate,\n                    curType: curType,\n                    newType: newType,\n                    references: []\n                  }; // console.warn(`${shapeLabel} ${tc.predicate} : ${newType} isn\\'t related to ${curType}`)\n\n                  predicates[tc.predicate].commonType = null;\n                } else {\n                  predicates[tc.predicate].commonType = intersection[0];\n                  predicates[tc.predicate].polymorphic = true;\n                }\n              } else {\n                predicates[tc.predicate].commonType = shapeHierarchy.parents[newType][idx];\n                predicates[tc.predicate].polymorphic = true;\n              }\n            }\n          }\n        });\n      }\n    });\n    return predicates;\n  }), _defineProperty(_ShExUtil2, \"simpleTripleConstraints\", function simpleTripleConstraints(shape) {\n    if (!('expression' in shape)) {\n      return [];\n    }\n\n    if (shape.expression.type === 'TripleConstraint') {\n      return [shape.expression];\n    }\n\n    if (shape.expression.type === 'EachOf' && !shape.expression.expressions.find(function (expr) {\n      return expr.type !== 'TripleConstraint';\n    })) {\n      return shape.expression.expressions;\n    }\n\n    throw Error('can\\'t (yet) express ' + JSON.stringify(shape));\n  }), _defineProperty(_ShExUtil2, \"skipDecl\", function skipDecl(shapeExpr) {\n    return shapeExpr.type === 'ShapeDecl' ? shapeExpr.shapeExpr : shapeExpr;\n  }), _defineProperty(_ShExUtil2, \"getValueType\", function getValueType(valueExpr) {\n    if (typeof valueExpr === 'string') {\n      return valueExpr;\n    }\n\n    if (valueExpr.reference) {\n      return valueExpr.reference;\n    }\n\n    if (valueExpr.nodeKind === 'iri') {\n      return OWL.Thing;\n    } // !! push this test to callers\n\n\n    if (valueExpr.datatype) {\n      return valueExpr.datatype;\n    } // if (valueExpr.extends && valueExpr.extends.length === 1) { return valueExpr.extends[0] }\n\n\n    return valueExpr; // throw Error('no value type for ' + JSON.stringify(valueExpr))\n  }), _defineProperty(_ShExUtil2, \"getDependencies\", function getDependencies(schema, ret) {\n    ret = ret || this.BiDiClosure();\n    (schema.shapes || []).forEach(function (shape) {\n      function _walkShapeExpression(shapeExpr, negated) {\n        if (typeof shapeExpr === \"string\") {\n          // ShapeRef\n          ret.add(shape.id, shapeExpr);\n        } else if (shapeExpr.type === \"ShapeOr\" || shapeExpr.type === \"ShapeAnd\") {\n          shapeExpr.shapeExprs.forEach(function (expr) {\n            _walkShapeExpression(expr, negated);\n          });\n        } else if (shapeExpr.type === \"ShapeNot\") {\n          _walkShapeExpression(shapeExpr.shapeExpr, negated ^ 1); // !!! test negation\n\n        } else if (shapeExpr.type === \"Shape\") {\n          _walkShape(shapeExpr, negated);\n        } else if (shapeExpr.type === \"NodeConstraint\") {// no impact on dependencies\n        } else if (shapeExpr.type === \"ShapeExternal\") {} else throw Error(\"expected Shape{And,Or,Ref,External} or NodeConstraint in \" + JSON.stringify(shapeExpr));\n      }\n\n      function _walkShape(shape, negated) {\n        function _walkTripleExpression(tripleExpr, negated) {\n          function _exprGroup(exprs, negated) {\n            exprs.forEach(function (nested) {\n              _walkTripleExpression(nested, negated); // ?? negation allowed?\n\n            });\n          }\n\n          function _walkTripleConstraint(tc, negated) {\n            if (tc.valueExpr) _walkShapeExpression(tc.valueExpr, negated);\n            if (negated && ret.inCycle.indexOf(shape.id) !== -1) // illDefined/negatedRefCycle.err\n              throw Error(\"Structural error: \" + shape.id + \" appears in negated cycle\");\n          }\n\n          if (typeof tripleExpr === \"string\") {\n            // Inclusion\n            ret.add(shape.id, tripleExpr);\n          } else {\n            if (\"id\" in tripleExpr) ret.addIn(tripleExpr.id, shape.id);\n\n            if (tripleExpr.type === \"TripleConstraint\") {\n              _walkTripleConstraint(tripleExpr, negated);\n            } else if (tripleExpr.type === \"OneOf\" || tripleExpr.type === \"EachOf\") {\n              _exprGroup(tripleExpr.expressions);\n            } else {\n              throw Error(\"expected {TripleConstraint,OneOf,EachOf,Inclusion} in \" + tripleExpr);\n            }\n          }\n        }\n\n        [\"extends\", \"restricts\"].forEach(function (attr) {\n          if (shape[attr] && shape[attr].length > 0) shape[attr].forEach(function (i) {\n            ret.add(shape.id, i);\n          });\n        });\n        if (shape.expression) _walkTripleExpression(shape.expression, negated);\n      }\n\n      if (shape.type === \"ShapeDecl\") shape = shape.shapeExpr;\n\n      _walkShapeExpression(shape, 0); // 0 means false for bitwise XOR\n\n    });\n    return ret;\n  }), _defineProperty(_ShExUtil2, \"partition\", function partition(schema, includes, deps, cantFind) {\n    var inputIndex = schema._index || this.index(schema);\n    var outputIndex = {\n      shapeExprs: new Map(),\n      tripleExprs: new Map()\n    };\n    includes = includes instanceof Array ? includes : [includes]; // build dependency tree if not passed one\n\n    deps = deps || this.getDependencies(schema);\n\n    cantFind = cantFind || function (what, why) {\n      throw new Error(\"Error: can't find shape \" + (why ? why + \" dependency \" + what : what));\n    };\n\n    var partition = {};\n\n    for (var k in schema) {\n      partition[k] = k === \"shapes\" ? [] : schema[k];\n    }\n\n    includes.forEach(function (i) {\n      if (i in outputIndex.shapeExprs) {// already got it.\n      } else if (i in inputIndex.shapeExprs) {\n        var adding = inputIndex.shapeExprs[i];\n        partition.shapes.push(adding);\n        outputIndex.shapeExprs[adding.id] = adding;\n        if (i in deps.needs) deps.needs[i].forEach(function (n) {\n          // Turn any needed TE into an SE.\n          if (n in deps.foundIn) n = deps.foundIn[n];\n\n          if (n in outputIndex.shapeExprs) {} else if (n in inputIndex.shapeExprs) {\n            var needed = inputIndex.shapeExprs[n];\n            partition.shapes.push(needed);\n            outputIndex.shapeExprs[needed.id] = needed;\n          } else cantFind(n, i);\n        });\n      } else {\n        cantFind(i, \"supplied\");\n      }\n    });\n    return partition;\n  }), _defineProperty(_ShExUtil2, \"flatten\", function flatten(schema, deps, cantFind) {\n    var v = this.Visitor();\n    return v.visitSchema(schema);\n  }), _defineProperty(_ShExUtil2, \"emptySchema\", function emptySchema() {\n    return {\n      type: \"Schema\"\n    };\n  }), _defineProperty(_ShExUtil2, \"merge\", function merge(left, right, overwrite, inPlace) {\n    var ret = inPlace ? left : this.emptySchema();\n\n    function mergeArray(attr) {\n      Object.keys(left[attr] || {}).forEach(function (key) {\n        if (!(attr in ret)) ret[attr] = {};\n        ret[attr][key] = left[attr][key];\n      });\n      Object.keys(right[attr] || {}).forEach(function (key) {\n        if (!(attr in left) || !(key in left[attr]) || overwrite) {\n          if (!(attr in ret)) ret[attr] = {};\n          ret[attr][key] = right[attr][key];\n        }\n      });\n    }\n\n    function mergeMap(attr) {\n      (left[attr] || new Map()).forEach(function (value, key, map) {\n        if (!(attr in ret)) ret[attr] = new Map();\n        ret[attr].set(key, left[attr].get(key));\n      });\n      (right[attr] || new Map()).forEach(function (value, key, map) {\n        if (!(attr in left) || !left[attr].has(key) || overwrite) {\n          if (!(attr in ret)) ret[attr] = new Map();\n          ret[attr].set(key, right[attr].get(key));\n        }\n      });\n    } // base\n\n\n    if (\"_base\" in left) ret._base = left._base;\n    if (\"_base\" in right) if (!(\"_base\" in left) || overwrite) ret._base = right._base;\n    mergeArray(\"_prefixes\");\n    mergeMap(\"_sourceMap\");\n    if (\"imports\" in right) if (!(\"imports\" in left) || overwrite) ret.imports = right.imports; // startActs\n\n    if (\"startActs\" in left) ret.startActs = left.startActs;\n    if (\"startActs\" in right) if (!(\"startActs\" in left) || overwrite) ret.startActs = right.startActs; // start\n\n    if (\"start\" in left) ret.start = left.start;\n    if (\"start\" in right) if (!(\"start\" in left) || overwrite) ret.start = right.start;\n    var lindex = left._index || this.index(left); // shapes\n\n    if (!inPlace) (left.shapes || []).forEach(function (lshape) {\n      if (!(\"shapes\" in ret)) ret.shapes = [];\n      ret.shapes.push(lshape);\n    });\n    (right.shapes || []).forEach(function (rshape) {\n      if (!(\"shapes\" in left) || !(rshape.id in lindex.shapeExprs) || overwrite) {\n        if (!(\"shapes\" in ret)) ret.shapes = [];\n        ret.shapes.push(rshape);\n      }\n    });\n    if (left._index || right._index) ret._index = this.index(ret); // inefficient; could build above\n\n    return ret;\n  }), _defineProperty(_ShExUtil2, \"absolutizeResults\", function absolutizeResults(parsed, base) {\n    // !! duplicate of Validation-test.js:84: var referenceResult = parseJSONFile(resultsFile...)\n    function mapFunction(k, obj) {\n      // resolve relative URLs in results file\n      if ([\"shape\", \"reference\", \"node\", \"subject\", \"predicate\", \"object\"].indexOf(k) !== -1 && RdfTerm.isIRI(obj[k])) {\n        obj[k] = RdfTerm.resolveRelativeIRI(base, obj[k]);\n      }\n    }\n\n    function resolveRelativeURLs(obj) {\n      Object.keys(obj).forEach(function (k) {\n        if (typeof obj[k] === \"object\") {\n          resolveRelativeURLs(obj[k]);\n        }\n\n        if (mapFunction) {\n          mapFunction(k, obj);\n        }\n      });\n    }\n\n    resolveRelativeURLs(parsed);\n    return parsed;\n  }), _defineProperty(_ShExUtil2, \"getProofGraph\", function getProofGraph(res, db, dataFactory) {\n    function _dive1(solns) {\n      if (solns.type === \"NodeTest\" || solns.type === \"NodeConstraintTest\") {} else if (solns.type === \"SolutionList\" || solns.type === \"ShapeAndResults\") {\n        solns.solutions.forEach(function (s) {\n          if (s.solution) // no .solution for <S> {}\n            _dive1(s.solution);\n        });\n      } else if (solns.type === \"ShapeOrResults\") {\n        _dive1(solns.solution);\n      } else if (solns.type === \"ShapeTest\") {\n        if (\"solution\" in solns) _dive1(solns.solution);\n      } else if (solns.type === \"OneOfSolutions\" || solns.type === \"EachOfSolutions\") {\n        solns.solutions.forEach(function (s) {\n          _dive1(s);\n        });\n      } else if (solns.type === \"OneOfSolution\" || solns.type === \"EachOfSolution\") {\n        solns.expressions.forEach(function (s) {\n          _dive1(s);\n        });\n      } else if (solns.type === \"TripleConstraintSolutions\") {\n        solns.solutions.map(function (s) {\n          if (s.type !== \"TestedTriple\") throw Error(\"unexpected result type: \" + s.type);\n          var s2 = s;\n          if (typeof s2.object === \"object\") s2.object = \"\\\"\" + s2.object.value.replace(/\"/g, \"\\\\\\\"\") + \"\\\"\" + (s2.object.language ? \"@\" + s2.object.language : s2.object.type ? \"^^\" + s2.object.type : \"\");\n          db.addQuad(RdfTerm.externalTriple(s2, dataFactory));\n\n          if (\"referenced\" in s) {\n            _dive1(s.referenced);\n          }\n        });\n      } else {\n        throw Error(\"unexpected expr type \" + solns.type + \" in \" + JSON.stringify(solns));\n      }\n    }\n\n    _dive1(res);\n\n    return db;\n  }), _defineProperty(_ShExUtil2, \"validateSchema\", function validateSchema(schema) {\n    // obselete, but may need other validations in the future.\n    var _ShExUtil = this;\n\n    var visitor = this.Visitor();\n    var currentLabel = currentExtra = null;\n    var currentNegated = false;\n    var dependsOn = {};\n    var inTE = false;\n    var oldVisitShape = visitor.visitShape;\n    var negativeDeps = Hierarchy.create();\n    var positiveDeps = Hierarchy.create();\n    var index = schema.index || this.index(schema);\n\n    visitor.visitShape = function (shape, label) {\n      var lastExtra = currentExtra;\n      currentExtra = shape.extra;\n      var ret = oldVisitShape.call(visitor, shape, label);\n      currentExtra = lastExtra;\n      return ret;\n    };\n\n    var oldVisitShapeNot = visitor.visitShapeNot;\n\n    visitor.visitShapeNot = function (shapeNot, label) {\n      var lastNegated = currentNegated;\n      currentNegated ^= true;\n      var ret = oldVisitShapeNot.call(visitor, shapeNot, label);\n      currentNegated = lastNegated;\n      return ret;\n    };\n\n    var oldVisitTripleConstraint = visitor.visitTripleConstraint;\n\n    visitor.visitTripleConstraint = function (expr) {\n      var lastNegated = currentNegated;\n      if (currentExtra && currentExtra.indexOf(expr.predicate) !== -1) currentNegated ^= true;\n      inTE = true;\n      var ret = oldVisitTripleConstraint.call(visitor, expr);\n      inTE = false;\n      currentNegated = lastNegated;\n      return ret;\n    };\n\n    var oldVisitShapeRef = visitor.visitShapeRef;\n\n    visitor.visitShapeRef = function (shapeRef) {\n      if (!(shapeRef in index.shapeExprs)) throw firstError(Error(\"Structural error: reference to \" + JSON.stringify(shapeRef) + \" not found in schema shape expressions:\\n\" + dumpKeys(index.shapeExprs) + \".\"), shapeRef);\n      if (!inTE && shapeRef === currentLabel) throw firstError(Error(\"Structural error: circular reference to \" + currentLabel + \".\"), shapeRef);\n      (currentNegated ? negativeDeps : positiveDeps).add(currentLabel, shapeRef);\n      return oldVisitShapeRef.call(visitor, shapeRef);\n    };\n\n    var oldVisitInclusion = visitor.visitInclusion;\n\n    visitor.visitInclusion = function (inclusion) {\n      var refd;\n      if (!(refd = index.tripleExprs[inclusion])) throw firstError(Error(\"Structural error: included shape \" + inclusion + \" not found in schema triple expressions:\\n\" + dumpKeys(index.tripleExprs) + \".\"), inclusion); // if (refd.type !== \"Shape\")\n      //   throw Error(\"Structural error: \" + inclusion + \" is not a simple shape.\");\n\n      return oldVisitInclusion.call(visitor, inclusion);\n    };\n\n    (schema.shapes || []).forEach(function (shape) {\n      currentLabel = shape.id;\n      visitor.visitShapeDecl(shape, shape.id);\n    });\n    var circs = Object.keys(negativeDeps.children).filter(function (k) {\n      return negativeDeps.children[k].filter(function (k2) {\n        return k2 in negativeDeps.children && negativeDeps.children[k2].indexOf(k) !== -1 || k2 in positiveDeps.children && positiveDeps.children[k2].indexOf(k) !== -1;\n      }).length > 0;\n    });\n    if (circs.length) throw firstError(Error(\"Structural error: circular negative dependencies on \" + circs.join(',') + \".\"), circs[0]);\n\n    function dumpKeys(obj) {\n      return obj ? Object.keys(obj).map(function (u) {\n        return u.substr(0, 2) === '_:' ? u : '<' + u + '>';\n      }).join(\"\\n        \") : '- none defined -';\n    }\n\n    function firstError(e, obj) {\n      if (\"_sourceMap\" in schema) e.location = (schema._sourceMap.get(obj) || [undefined])[0];\n      return e;\n    }\n  }), _defineProperty(_ShExUtil2, \"isWellDefined\", function isWellDefined(schema) {\n    this.validateSchema(schema); // var deps = this.getDependencies(schema);\n\n    return schema;\n  }), _defineProperty(_ShExUtil2, \"walkVal\", function walkVal(val, cb) {\n    var _ShExUtil = this;\n\n    if (val.type === \"NodeTest\") {\n      return null;\n    } else if (val.type === \"ShapeTest\") {\n      return \"solution\" in val ? _ShExUtil.walkVal(val.solution, cb) : null;\n    } else if (val.type === \"ShapeOrResults\") {\n      return _ShExUtil.walkVal(val.solution || val.solutions, cb);\n    } else if (val.type === \"ShapeAndResults\") {\n      return val.solutions.reduce(function (ret, exp) {\n        var n = _ShExUtil.walkVal(exp, cb);\n\n        if (n) Object.keys(n).forEach(function (k) {\n          if (k in ret) ret[k] = ret[k].concat(n[k]);else ret[k] = n[k];\n        });\n        return ret;\n      }, {});\n    } else if (val.type === \"EachOfSolutions\" || val.type === \"OneOfSolutions\") {\n      return val.solutions.reduce(function (ret, sln) {\n        sln.expressions.forEach(function (exp) {\n          var n = _ShExUtil.walkVal(exp, cb);\n\n          if (n) Object.keys(n).forEach(function (k) {\n            if (k in ret) ret[k] = ret[k].concat(n[k]);else ret[k] = n[k];\n          });\n        });\n        return ret;\n      }, {});\n    } else if (val.type === \"OneOfSolutions\") {\n      return val.solutions.reduce(function (ret, sln) {\n        Object.assign(ret, _ShExUtil.walkVal(sln, cb));\n        return ret;\n      }, {});\n    } else if (val.type === \"TripleConstraintSolutions\") {\n      if (\"solutions\" in val) {\n        var ret = {};\n        var vals = [];\n        ret[val.predicate] = vals;\n        val.solutions.forEach(function (sln) {\n          var toAdd = [];\n\n          if (chaseList(sln.referenced, toAdd)) {\n            vals = vals.concat(toAdd);\n          } else {\n            var newElt = cb(sln);\n\n            if (\"referenced\" in sln) {\n              var t = _ShExUtil.walkVal(sln.referenced, cb);\n\n              if (t) newElt.nested = t;\n            }\n\n            vals.push(newElt);\n          }\n\n          function chaseList(li) {\n            if (!li) return false;\n            if (li.node === RDF.nil) return true;\n\n            if (\"solution\" in li && \"solutions\" in li.solution && li.solution.solutions.length === 1 && \"expressions\" in li.solution.solutions[0] && li.solution.solutions[0].expressions.length === 2 && \"predicate\" in li.solution.solutions[0].expressions[0] && li.solution.solutions[0].expressions[0].predicate === RDF.first && li.solution.solutions[0].expressions[1].predicate === RDF.rest) {\n              var expressions = li.solution.solutions[0].expressions;\n              var ent = expressions[0];\n              var rest = expressions[1].solutions[0];\n              var member = ent.solutions[0];\n              var newElt = cb(member);\n\n              if (\"referenced\" in member) {\n                var t = _ShExUtil.walkVal(member.referenced, cb);\n\n                if (t) newElt.nested = t;\n              }\n\n              vals.push(newElt);\n              return rest.object === RDF.nil ? true : chaseList(rest.referenced.type === \"ShapeOrResults\" // heuristic for `nil  OR @<list>` idiom\n              ? rest.referenced.solution : rest.referenced);\n            }\n          }\n        });\n        return vals.length ? ret : null;\n      } else {\n        return null;\n      }\n    } else if (val.type === \"NodeConstraintTest\") {\n      return null;\n    } else if (val.type === \"Recursion\") {\n      return null;\n    } else {\n      // console.log(val);\n      throw Error(\"unknown shapeExpression type in \" + JSON.stringify(val));\n    }\n\n    return val;\n  }), _defineProperty(_ShExUtil2, \"valToValues\", function valToValues(val) {\n    return this.walkVal(val, function (sln) {\n      return {\n        ldterm: sln.object\n      };\n    });\n  }), _defineProperty(_ShExUtil2, \"valToExtension\", function valToExtension(val, lookfor) {\n    var map = this.walkVal(val, function (sln) {\n      return {\n        extensions: sln.extensions\n      };\n    });\n\n    function extensions(obj) {\n      var list = [];\n      var crushed = {};\n\n      function crush(elt) {\n        if (crushed === null) return elt;\n\n        if (elt.constructor === Array) {\n          crushed = null;\n          return elt;\n        }\n\n        for (k in elt) {\n          if (k in crushed) {\n            crushed = null;\n            return elt;\n          }\n\n          crushed[k] = elt[k];\n        }\n\n        return elt;\n      }\n\n      for (var k in obj) {\n        if (k === \"extensions\") {\n          if (obj[k]) list.push(crush(obj[k][lookfor]));\n        } else if (k === \"nested\") {\n          var nested = extensions(obj[k]);\n          if (nested.constructor === Array) nested.forEach(crush);else crush(nested);\n          list = list.concat(nested);\n        } else {\n          list.push(crush(extensions(obj[k])));\n        }\n      }\n\n      return list.length === 1 ? list[0] : crushed ? crushed : list;\n    }\n\n    return extensions(map);\n  }), _defineProperty(_ShExUtil2, \"valuesToSchema\", function valuesToSchema(values) {\n    // console.log(JSON.stringify(values, null, \"  \"));\n    var v = values;\n    var t = values[RDF.type][0].ldterm;\n\n    if (t === SX.Schema) {\n      /* Schema { \"@context\":\"http://www.w3.org/ns/shex.jsonld\"\n       *           startActs:[SemAct+]? start:(shapeExpr|labeledShapeExpr)?\n       *           shapes:[labeledShapeExpr+]? }\n       */\n      var ret = {\n        \"@context\": \"http://www.w3.org/ns/shex.jsonld\",\n        type: \"Schema\"\n      };\n      if (SX.startActs in v) ret.startActs = v[SX.startActs].map(function (e) {\n        var ret = {\n          type: \"SemAct\",\n          name: e.nested[SX.name][0].ldterm\n        };\n        if (SX.code in e.nested) ret.code = e.nested[SX.code][0].ldterm.value;\n        return ret;\n      });\n      if (SX.imports in v) ret.imports = v[SX.imports].map(function (e) {\n        return e.ldterm;\n      });\n      if (values[SX.start]) ret.start = extend({\n        id: values[SX.start][0].ldterm\n      }, shapeExpr(values[SX.start][0].nested));\n      var shapes = values[SX.shapes];\n\n      if (shapes) {\n        ret.shapes = shapes.map(function (v) {\n          // @@ console.log(v.nested);\n          var t = v.nested[RDF.type][0].ldterm;\n          var obj = t === SX.ShapeDecl ? {\n            type: SX.ShapeDecl,\n            abstract: !!v.nested[SX[\"abstract\"]][0].ldterm.value,\n            shapeExpr: shapeExpr(v.nested[SX.shapeExpr][0].nested)\n          } : shapeExpr(v.nested);\n          return extend({\n            id: v.ldterm\n          }, obj);\n        });\n      } // console.log(ret);\n\n\n      return ret;\n    } else {\n      throw Error(\"unknown schema type in \" + JSON.stringify(values));\n    }\n\n    function findType(v, elts, f) {\n      var t = v[RDF.type][0].ldterm.substr(SX._namespace.length);\n      var elt = elts[t];\n      if (!elt) return Missed;\n\n      if (elt.nary) {\n        var ret = {\n          type: t\n        };\n        ret[elt.prop] = v[SX[elt.prop]].map(function (e) {\n          return valueOf(e);\n        });\n        return ret;\n      } else {\n        var ret = {\n          type: t\n        };\n\n        if (elt.prop) {\n          ret[elt.prop] = valueOf(v[SX[elt.prop]][0]);\n        }\n\n        return ret;\n      }\n\n      function valueOf(x) {\n        return elt.expr && \"nested\" in x ? extend({\n          id: x.ldterm\n        }, f(x.nested)) : x.ldterm;\n      }\n    }\n\n    function shapeExpr(v) {\n      // shapeExpr = ShapeOr | ShapeAnd | ShapeNot | NodeConstraint | Shape | ShapeRef | ShapeExternal;\n      var elts = {\n        \"ShapeAnd\": {\n          nary: true,\n          expr: true,\n          prop: \"shapeExprs\"\n        },\n        \"ShapeOr\": {\n          nary: true,\n          expr: true,\n          prop: \"shapeExprs\"\n        },\n        \"ShapeNot\": {\n          nary: false,\n          expr: true,\n          prop: \"shapeExpr\"\n        },\n        \"ShapeRef\": {\n          nary: false,\n          expr: false,\n          prop: \"reference\"\n        },\n        \"ShapeExternal\": {\n          nary: false,\n          expr: false,\n          prop: null\n        }\n      };\n      var ret = findType(v, elts, shapeExpr);\n      if (ret !== Missed) return ret;\n      var t = v[RDF.type][0].ldterm;\n\n      if (t === SX.ShapeDecl) {\n        var ret = {\n          type: \"ShapeDecl\"\n        };\n        [\"abstract\"].forEach(function (a) {\n          if (SX[a] in v) ret[a] = !!v[SX[a]][0].ldterm.value;\n        });\n\n        if (SX.shapeExpr in v) {\n          ret.shapeExpr = \"nested\" in v[SX.shapeExpr][0] ? extend({\n            id: v[SX.shapeExpr][0].ldterm\n          }, shapeExpr(v[SX.shapeExpr][0].nested)) : v[SX.shapeExpr][0].ldterm;\n        }\n\n        return ret;\n      } else if (t === SX.Shape) {\n        var ret = {\n          type: \"Shape\"\n        };\n        [\"closed\"].forEach(function (a) {\n          if (SX[a] in v) ret[a] = !!v[SX[a]][0].ldterm.value;\n        });\n        [\"extra\", \"extends\", \"restricts\"].forEach(function (a) {\n          if (SX[a] in v) ret[a] = v[SX[a]].map(function (e) {\n            return e.ldterm;\n          });\n        });\n\n        if (SX.expression in v) {\n          ret.expression = \"nested\" in v[SX.expression][0] ? extend({\n            id: v[SX.expression][0].ldterm\n          }, tripleExpr(v[SX.expression][0].nested)) : v[SX.expression][0].ldterm;\n        }\n\n        if (SX.annotation in v) ret.annotations = v[SX.annotation].map(function (e) {\n          return {\n            type: \"Annotation\",\n            predicate: e.nested[SX.predicate][0].ldterm,\n            object: e.nested[SX.object][0].ldterm\n          };\n        });\n        if (SX.semActs in v) ret.semActs = v[SX.semActs].map(function (e) {\n          var ret = {\n            type: \"SemAct\",\n            name: e.nested[SX.name][0].ldterm\n          };\n          if (SX.code in e.nested) ret.code = e.nested[SX.code][0].ldterm.value;\n          return ret;\n        });\n        return ret;\n      } else if (t === SX.NodeConstraint) {\n        var ret = {\n          type: \"NodeConstraint\"\n        };\n        if (SX.values in v) ret.values = v[SX.values].map(function (v1) {\n          return objectValue(v1);\n        });\n        if (SX.nodeKind in v) ret.nodeKind = v[SX.nodeKind][0].ldterm.substr(SX._namespace.length);\n        [\"length\", \"minlength\", \"maxlength\", \"mininclusive\", \"maxinclusive\", \"minexclusive\", \"maxexclusive\", \"totaldigits\", \"fractiondigits\"].forEach(function (a) {\n          if (SX[a] in v) ret[a] = parseFloat(v[SX[a]][0].ldterm.value);\n        });\n        if (SX.pattern in v) ret.pattern = v[SX.pattern][0].ldterm.value;\n        if (SX.flags in v) ret.flags = v[SX.flags][0].ldterm.value;\n        if (SX.datatype in v) ret.datatype = v[SX.datatype][0].ldterm;\n        return ret;\n      } else {\n        throw Error(\"unknown shapeExpr type in \" + JSON.stringify(v));\n      }\n    }\n\n    function objectValue(v, expectString) {\n      if (\"nested\" in v) {\n        var t = v.nested[RDF.type][0].ldterm;\n\n        if ([SX.IriStem, SX.LiteralStem, SX.LanguageStem].indexOf(t) !== -1) {\n          var ldterm = v.nested[SX.stem][0].ldterm.value;\n          return {\n            type: t.substr(SX._namespace.length),\n            stem: ldterm\n          };\n        } else if ([SX.Language].indexOf(t) !== -1) {\n          return {\n            type: \"Language\",\n            languageTag: v.nested[SX.languageTag][0].ldterm.value\n          };\n        } else if ([SX.IriStemRange, SX.LiteralStemRange, SX.LanguageStemRange].indexOf(t) !== -1) {\n          var st = v.nested[SX.stem][0];\n          var stem = st;\n\n          if (typeof st === \"object\") {\n            if (typeof st.ldterm === \"object\") {\n              stem = st.ldterm;\n            } else if (st.ldterm.startsWith(\"_:\")) {\n              stem = {\n                type: \"Wildcard\"\n              };\n            }\n          }\n\n          var ret = {\n            type: t.substr(SX._namespace.length),\n            stem: stem.type !== \"Wildcard\" ? stem.value : stem\n          };\n\n          if (SX.exclusion in v.nested) {\n            // IriStemRange:\n            // * [{\"ldterm\":\"http://a.example/v1\"},{\"ldterm\":\"http://a.example/v3\"}] <-- no value\n            // * [{\"ldterm\":\"_:b836\",\"nested\":{a:[{\"ldterm\":sx:IriStem}],\n            //                                 sx:stem:[{\"ldterm\":{\"value\":\"http://a.example/v1\"}}]}},\n            //    {\"ldterm\":\"_:b838\",\"nested\":{a:[{\"ldterm\":sx:IriStem}],\n            //                                 sx:stem:[{\"ldterm\":{\"value\":\"http://a.example/v3\"}}]}}]\n            // LiteralStemRange:\n            // * [{\"ldterm\":{\"value\":\"v1\"}},{\"ldterm\":{\"value\":\"v3\"}}]\n            // * [{\"ldterm\":\"_:b866\",\"nested\":{a:[{\"ldterm\":sx:LiteralStem}],\n            //                                 sx:stem:[{\"ldterm\":{\"value\":\"v1\"}}]}},\n            //    {\"ldterm\":\"_:b868\",\"nested\":{a:[{\"ldterm\":sx:LiteralStem}],\n            //                                 sx:stem:[{\"ldterm\":{\"value\":\"v3\"}}]}}]\n            // LanguageStemRange:\n            // * [{\"ldterm\":{\"value\":\"fr-be\"}},{\"ldterm\":{\"value\":\"fr-ch\"}}]\n            // * [{\"ldterm\":\"_:b851\",\"nested\":{a:[{\"ldterm\":sx:LanguageStem}],\n            //                                 sx:stem:[{\"ldterm\":{\"value\":\"fr-be\"}}]}},\n            //    {\"ldterm\":\"_:b853\",\"nested\":{a:[{\"ldterm\":sx:LanguageStem}],\n            //                                 sx:stem:[{\"ldterm\":{\"value\":\"fr-ch\"}}]}}]\n            ret.exclusions = v.nested[SX.exclusion].map(function (v1) {\n              return objectValue(v1, t !== SX.IriStemRange);\n            });\n          }\n\n          return ret;\n        } else {\n          throw Error(\"unknown objectValue type in \" + JSON.stringify(v));\n        }\n      } else {\n        return expectString ? v.ldterm.value : v.ldterm;\n      }\n    }\n\n    function tripleExpr(v) {\n      // tripleExpr = EachOf | OneOf | TripleConstraint | Inclusion ;\n      var elts = {\n        \"EachOf\": {\n          nary: true,\n          expr: true,\n          prop: \"expressions\"\n        },\n        \"OneOf\": {\n          nary: true,\n          expr: true,\n          prop: \"expressions\"\n        },\n        \"Inclusion\": {\n          nary: false,\n          expr: false,\n          prop: \"include\"\n        }\n      };\n      var ret = findType(v, elts, tripleExpr);\n\n      if (ret !== Missed) {\n        minMaxAnnotSemActs(v, ret);\n        return ret;\n      }\n\n      var t = v[RDF.type][0].ldterm;\n\n      if (t === SX.TripleConstraint) {\n        var ret = {\n          type: \"TripleConstraint\",\n          predicate: v[SX.predicate][0].ldterm\n        };\n        [\"inverse\"].forEach(function (a) {\n          if (SX[a] in v) ret[a] = !!v[SX[a]][0].ldterm.value;\n        });\n        if (SX.valueExpr in v) ret.valueExpr = extend({\n          id: v[SX.valueExpr][0].ldterm\n        }, \"nested\" in v[SX.valueExpr][0] ? shapeExpr(v[SX.valueExpr][0].nested) : {});\n        minMaxAnnotSemActs(v, ret);\n        return ret;\n      } else {\n        throw Error(\"unknown tripleExpr type in \" + JSON.stringify(v));\n      }\n    }\n\n    function minMaxAnnotSemActs(v, ret) {\n      if (SX.min in v) ret.min = parseInt(v[SX.min][0].ldterm.value);\n\n      if (SX.max in v) {\n        ret.max = parseInt(v[SX.max][0].ldterm.value);\n        if (isNaN(ret.max)) ret.max = UNBOUNDED;\n      }\n\n      if (SX.annotation in v) ret.annotations = v[SX.annotation].map(function (e) {\n        return {\n          type: \"Annotation\",\n          predicate: e.nested[SX.predicate][0].ldterm,\n          object: e.nested[SX.object][0].ldterm\n        };\n      });\n      if (SX.semActs in v) ret.semActs = v[SX.semActs].map(function (e) {\n        var ret = {\n          type: \"SemAct\",\n          name: e.nested[SX.name][0].ldterm\n        };\n        if (SX.code in e.nested) ret.code = e.nested[SX.code][0].ldterm.value;\n        return ret;\n      });\n      return ret;\n    }\n  }), _defineProperty(_ShExUtil2, \"valToSimple\", function valToSimple(val) {\n    var _ShExUtil = this;\n\n    function _join(list) {\n      return list.reduce(function (ret, elt) {\n        Object.keys(elt).forEach(function (k) {\n          if (k in ret) {\n            ret[k] = Array.from(new Set(ret[k].concat(elt[k])));\n          } else {\n            ret[k] = elt[k];\n          }\n        });\n        return ret;\n      }, {});\n    }\n\n    if (val.type === \"TripleConstraintSolutions\") {\n      if (\"solutions\" in val) {\n        return val.solutions.reduce(function (ret, sln) {\n          if (!(\"referenced\" in sln)) return {};\n          var toAdd = {};\n\n          if (chaseList(sln.referenced, toAdd)) {\n            return _join(ret, toAdd);\n          } else {\n            return _join(ret, _ShExUtil.valToSimple(sln.referenced));\n          }\n\n          function chaseList(li) {\n            if (!li) return false;\n            if (li.node === RDF.nil) return true;\n\n            if (\"solution\" in li && \"solutions\" in li.solution && li.solution.solutions.length === 1 && \"expressions\" in li.solution.solutions[0] && li.solution.solutions[0].expressions.length === 2 && \"predicate\" in li.solution.solutions[0].expressions[0] && li.solution.solutions[0].expressions[0].predicate === RDF.first && li.solution.solutions[0].expressions[1].predicate === RDF.rest) {\n              var expressions = li.solution.solutions[0].expressions;\n              var ent = expressions[0];\n              var rest = expressions[1].solutions[0];\n              var member = ent.solutions[0];\n              var newElt = {\n                ldterm: member.object\n              };\n\n              if (\"referenced\" in member) {\n                var t = _ShExUtil.valToSimple(member.referenced);\n\n                if (t) newElt.nested = t;\n              }\n\n              toAdd = _join(toAdd, newElt);\n              return rest.object === RDF.nil ? true : chaseList(rest.referenced);\n            }\n          }\n        }, []);\n      } else {\n        return [];\n      }\n    } else if ([\"TripleConstraintSolutions\"].indexOf(val.type) !== -1) {\n      return {};\n    } else if (val.type === \"NodeTest\") {\n      var thisNode = {};\n      thisNode[n3ify(val.node)] = [val.shape];\n      return thisNode;\n    } else if (val.type === \"ShapeTest\") {\n      var thisNode = {};\n      thisNode[n3ify(val.node)] = [val.shape];\n      return \"solution\" in val ? _join([thisNode].concat(_ShExUtil.valToSimple(val.solution))) : thisNode;\n    } else if (val.type === \"Recursion\") {\n      return {};\n    } else if (\"solutions\" in val) {\n      // [\"SolutionList\", \"EachOfSolutions\", \"OneOfSolutions\", \"ShapeAndResults\", \"ShapeOrResults\"].indexOf(val.type) !== -1\n      return _join(val.solutions.map(function (sln) {\n        return _ShExUtil.valToSimple(sln);\n      }));\n    } else if (\"expressions\" in val) {\n      return _join(val.expressions.map(function (sln) {\n        return _ShExUtil.valToSimple(sln);\n      }));\n    } else {\n      // console.log(val);\n      throw Error(\"unknown shapeExpression type in \" + JSON.stringify(val));\n    }\n\n    return val;\n  }), _defineProperty(_ShExUtil2, \"simpleToShapeMap\", function simpleToShapeMap(x) {\n    return Object.keys(x).reduce(function (ret, k) {\n      x[k].forEach(function (s) {\n        ret.push({\n          node: k,\n          shape: s\n        });\n      });\n      return ret;\n    }, []);\n  }), _defineProperty(_ShExUtil2, \"absolutizeShapeMap\", function absolutizeShapeMap(parsed, base) {\n    return parsed.map(function (elt) {\n      return Object.assign(elt, {\n        node: RdfTerm.resolveRelativeIRI(base, elt.node),\n        shape: RdfTerm.resolveRelativeIRI(base, elt.shape)\n      });\n    });\n  }), _defineProperty(_ShExUtil2, \"errsToSimple\", function errsToSimple(val, node, shape) {\n    var _ShExUtil = this;\n\n    if (val.type === \"FailureList\") {\n      return val.errors.reduce(function (ret, e) {\n        return ret.concat(_ShExUtil.errsToSimple(e));\n      }, []);\n    } else if (val.type === \"Failure\") {\n      return [\"validating \" + val.node + \" as \" + val.shape + \":\"].concat(errorList(val.errors).reduce(function (ret, e) {\n        var nested = _ShExUtil.errsToSimple(e).map(function (s) {\n          return \"  \" + s;\n        });\n\n        return ret.length > 0 ? ret.concat([\"  OR\"]).concat(nested) : nested.map(function (s) {\n          return \"  \" + s;\n        });\n      }, []));\n    } else if (val.type === \"TypeMismatch\") {\n      var nested = val.errors.constructor === Array ? val.errors.reduce(function (ret, e) {\n        return ret.concat((typeof e === \"string\" ? [e] : _ShExUtil.errsToSimple(e)).map(function (s) {\n          return \"  \" + s;\n        }));\n      }, []) : \"  \" + (typeof e === \"string\" ? [val.errors] : _ShExUtil.errsToSimple(val.errors));\n      return [\"validating \" + n3ify(val.triple.object) + \":\"].concat(nested);\n    } else if (val.type === \"RestrictionError\") {\n      var nested = val.errors.constructor === Array ? val.errors.reduce(function (ret, e) {\n        return ret.concat((typeof e === \"string\" ? [e] : _ShExUtil.errsToSimple(e)).map(function (s) {\n          return \"  \" + s;\n        }));\n      }, []) : \"  \" + (typeof e === \"string\" ? [val.errors] : _ShExUtil.errsToSimple(val.errors));\n      return [\"validating restrictions on \" + n3ify(val.focus) + \":\"].concat(nested);\n    } else if (val.type === \"ShapeAndFailure\") {\n      return val.errors.constructor === Array ? val.errors.reduce(function (ret, e) {\n        return ret.concat((typeof e === \"string\" ? [e] : _ShExUtil.errsToSimple(e)).map(function (s) {\n          return \"  \" + s;\n        }));\n      }, []) : \"  \" + (typeof e === \"string\" ? [val.errors] : _ShExUtil.errsToSimple(val.errors));\n    } else if (val.type === \"ShapeOrFailure\") {\n      return val.errors.constructor === Array ? val.errors.reduce(function (ret, e) {\n        return ret.concat(\" OR \" + (typeof e === \"string\" ? [e] : _ShExUtil.errsToSimple(e)));\n      }, []) : \" OR \" + (typeof e === \"string\" ? [val.errors] : _ShExUtil.errsToSimple(val.errors));\n    } else if (val.type === \"ShapeNotFailure\") {\n      return [\"Node \" + val.errors.node + \" expected to NOT pass \" + val.errors.shape];\n    } else if (val.type === \"ExcessTripleViolation\") {\n      return [\"validating \" + n3ify(val.triple.object) + \": exceeds cardinality\"];\n    } else if (val.type === \"ClosedShapeViolation\") {\n      return [\"ClosedShapeError: unexpected: {\"].concat(val.unexpectedTriples.map(function (t) {\n        return \"  \" + t.subject + \" \" + t.predicate + \" \" + n3ify(t.object) + \" .\";\n      })).concat([\"}\"]);\n    } else if (val.type === \"NodeConstraintViolation\") {\n      var w = require(\"../lib/ShExWriter\")();\n\n      w._write(w._writeNodeConstraint(val.shapeExpr).join(\"\"));\n\n      var txt;\n      w.end(function (err, res) {\n        txt = res;\n      });\n      return [\"NodeConstraintError: expected to match \" + txt];\n    } else if (val.type === \"MissingProperty\") {\n      return [\"Missing property: \" + val.property];\n    } else if (val.type === \"NegatedProperty\") {\n      return [\"Unexpected property: \" + val.property];\n    } else if (val.type === \"AbstractShapeFailure\") {\n      return [\"Abstract Shape: \" + val.shape];\n    } else if (val.constructor === Array) {\n      return val.reduce(function (ret, e) {\n        var nested = _ShExUtil.errsToSimple(e).map(function (s) {\n          return \"  \" + s;\n        });\n\n        return ret.length ? ret.concat([\"AND\"]).concat(nested) : nested;\n      }, []);\n    } else if (val.type === \"SemActFailure\") {\n      var nested = val.errors.constructor === Array ? val.errors.reduce(function (ret, e) {\n        return ret.concat((typeof e === \"string\" ? [e] : _ShExUtil.errsToSimple(e)).map(function (s) {\n          return \"  \" + s;\n        }));\n      }, []) : \"  \" + (typeof e === \"string\" ? [val.errors] : _ShExUtil.errsToSimple(val.errors));\n      return [\"rejected by semantic action:\"].concat(nested);\n    } else if (val.type === \"SemActViolation\") {\n      return [val.message];\n    } else if (val.type === \"BooleanSemActFailure\") {\n      return [\"Failed evaluating \" + val.code + \" on context \" + JSON.stringify(val.ctx)];\n    } else {\n      debugger; // console.log(val);\n\n      throw Error(\"unknown shapeExpression type in \" + JSON.stringify(val));\n    }\n\n    function errorList(errors) {\n      return errors.reduce(function (acc, e) {\n        var attrs = Object.keys(e);\n        return acc.concat(attrs.length === 1 && attrs[0] === \"errors\" ? errorList(e.errors) : e);\n      }, []);\n    }\n  }), _defineProperty(_ShExUtil2, \"resolveRelativeIRI\", RdfTerm.resolveRelativeIRI), _defineProperty(_ShExUtil2, \"resolvePrefixedIRI\", function resolvePrefixedIRI(prefixedIri, prefixes) {\n    var colon = prefixedIri.indexOf(\":\");\n    if (colon === -1) return null;\n    var prefix = prefixes[prefixedIri.substr(0, colon)];\n    return prefix === undefined ? null : prefix + prefixedIri.substr(colon + 1);\n  }), _defineProperty(_ShExUtil2, \"parsePassedNode\", function parsePassedNode(passedValue, meta, deflt, known, reportUnknown) {\n    if (passedValue === undefined || passedValue.length === 0) return known && known(meta.base) ? meta.base : deflt ? deflt() : this.NotSupplied;\n    if (passedValue[0] === \"_\" && passedValue[1] === \":\") return passedValue;\n\n    if (passedValue[0] === \"\\\"\") {\n      var m = passedValue.match(/^\"((?:[^\"\\\\]|\\\\\")*)\"(?:@(.+)|\\^\\^(?:<(.*)>|([^:]*):(.*)))?$/);\n      if (!m) throw Error(\"malformed literal: \" + passedValue);\n      var lex = m[1],\n          lang = m[2],\n          rel = m[3],\n          pre = m[4],\n          local = m[5]; // Turn the literal into an N3.js atom.\n\n      var quoted = \"\\\"\" + lex + \"\\\"\";\n      if (lang !== undefined) return quoted + \"@\" + lang;\n\n      if (pre !== undefined) {\n        if (!(pre in meta.prefixes)) throw Error(\"error parsing node \" + passedValue + \" no prefix for \\\"\" + pre + \"\\\"\");\n        return quoted + \"^^\" + meta.prefixes[pre] + local;\n      }\n\n      if (rel !== undefined) return quoted + \"^^\" + RdfTerm.resolveRelativeIRI(meta.base, rel);\n      return quoted;\n    }\n\n    if (!meta) return known(passedValue) ? passedValue : this.UnknownIRI;\n    var relIRI = passedValue[0] === \"<\" && passedValue[passedValue.length - 1] === \">\";\n    if (relIRI) passedValue = passedValue.substr(1, passedValue.length - 2);\n    var t = RdfTerm.resolveRelativeIRI(meta.base || \"\", passedValue); // fall back to base-less mode\n\n    if (known(t)) return t;\n\n    if (!relIRI) {\n      var t2 = this.resolvePrefixedIRI(passedValue, meta.prefixes);\n      if (t2 !== null && known(t2)) return t2;\n    }\n\n    return reportUnknown ? reportUnknown(t) : this.UnknownIRI;\n  }), _defineProperty(_ShExUtil2, \"executeQueryPromise\", function executeQueryPromise(query, endpoint) {\n    var rows;\n    var queryURL = endpoint + \"?query=\" + encodeURIComponent(query);\n    return fetch(queryURL, {\n      headers: {\n        'Accept': 'application/sparql-results+json'\n      }\n    }).then(function (resp) {\n      return resp.json();\n    }).then(function (t) {\n      var selects = t.head.vars;\n      return t.results.bindings.map(function (row) {\n        return selects.map(function (sel) {\n          var elt = row[sel];\n\n          switch (elt.type) {\n            case \"uri\":\n              return elt.value;\n\n            case \"bnode\":\n              return \"_:\" + elt.value;\n\n            case \"literal\":\n              var datatype = elt.datatype;\n              var lang = elt[\"xml:lang\"];\n              return \"\\\"\" + elt.value + \"\\\"\" + (datatype ? \"^^\" + datatype : lang ? \"@\" + lang : \"\");\n\n            default:\n              throw \"unknown XML results type: \" + elt.prop(\"tagName\");\n          }\n\n          return row[sel];\n        });\n      });\n    }); // .then(x => new Promise(resolve => setTimeout(() => resolve(x), 1000)));\n  }), _defineProperty(_ShExUtil2, \"executeQuery\", function executeQuery(query, endpoint) {\n    var rows, t, j;\n    var queryURL = endpoint + \"?query=\" + encodeURIComponent(query);\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", queryURL, false);\n    xhr.setRequestHeader('Accept', 'application/sparql-results+json');\n    xhr.send(); // var selectsBlock = query.match(/SELECT\\s*(.*?)\\s*{/)[1];\n    // var selects = selectsBlock.match(/\\?[^\\s?]+/g);\n\n    var t = JSON.parse(xhr.responseText);\n    var selects = t.head.vars;\n    return t.results.bindings.map(function (row) {\n      return selects.map(function (sel) {\n        var elt = row[sel];\n\n        switch (elt.type) {\n          case \"uri\":\n            return elt.value;\n\n          case \"bnode\":\n            return \"_:\" + elt.value;\n\n          case \"literal\":\n            var datatype = elt.datatype;\n            var lang = elt[\"xml:lang\"];\n            return \"\\\"\" + elt.value + \"\\\"\" + (datatype ? \"^^\" + datatype : lang ? \"@\" + lang : \"\");\n\n          default:\n            throw \"unknown XML results type: \" + elt.prop(\"tagName\");\n        }\n\n        return row[sel];\n      });\n    });\n    /* TO ADD? XML results format parsed with jquery:\n            $(data).find(\"sparql > results > result\").\n              each((_, row) => {\n                rows.push($(row).find(\"binding > *:nth-child(1)\").\n                  map((idx, elt) => {\n                    elt = $(elt);\n                    var text = elt.text();\n                    switch (elt.prop(\"tagName\")) {\n                    case \"uri\": return text;\n                    case \"bnode\": return \"_:\" + text;\n                    case \"literal\":\n                      var datatype = elt.attr(\"datatype\");\n                      var lang = elt.attr(\"xml:lang\");\n                      return \"\\\"\" + text + \"\\\"\" + (\n                        datatype ? \"^^\" + datatype :\n                        lang ? \"@\" + lang :\n                          \"\");\n                    default: throw \"unknown XML results type: \" + elt.prop(\"tagName\");\n                    }\n                  }).get());\n              });\n    */\n  }), _defineProperty(_ShExUtil2, \"makeN3DB\", function makeN3DB(db, queryTracker) {\n    function getSubjects() {\n      return db.getSubjects().map(RdfTerm.internalTerm);\n    }\n\n    function getPredicates() {\n      return db.getPredicates().map(RdfTerm.internalTerm);\n    }\n\n    function getObjects() {\n      return db.getObjects().map(RdfTerm.internalTerm);\n    }\n\n    function getQuads() {\n      return db.getQuads.apply(db, arguments).map(RdfTerm.internalTriple);\n    }\n\n    function getNeighborhood(point, shapeLabel\n    /*, shape */\n    ) {\n      // I'm guessing a local DB doesn't benefit from shape optimization.\n      var startTime;\n\n      if (queryTracker) {\n        startTime = new Date();\n        queryTracker.start(false, point, shapeLabel);\n      }\n\n      var outgoing = db.getQuads(point, null, null, null).map(RdfTerm.internalTriple);\n\n      if (queryTracker) {\n        var time = new Date();\n        queryTracker.end(outgoing, time - startTime);\n        startTime = time;\n      }\n\n      if (queryTracker) {\n        queryTracker.start(true, point, shapeLabel);\n      }\n\n      var incoming = db.getQuads(null, null, point, null).map(RdfTerm.internalTriple);\n\n      if (queryTracker) {\n        queryTracker.end(incoming, new Date() - startTime);\n      }\n\n      return {\n        outgoing: outgoing,\n        incoming: incoming\n      };\n    }\n\n    return {\n      // size: db.size,\n      getNeighborhood: getNeighborhood,\n      getSubjects: getSubjects,\n      getPredicates: getPredicates,\n      getObjects: getObjects,\n      getQuads: getQuads,\n\n      get size() {\n        return db.size;\n      } // getQuads: function (s, p, o, graph, shapeLabel) {\n      //   // console.log(Error(s + p + o).stack)\n      //   if (queryTracker)\n      //     queryTracker.start(!!s, s ? s : o, shapeLabel);\n      //   var quads = db.getQuads(s, p, o, graph)\n      //   if (queryTracker)\n      //     queryTracker.end(quads, new Date() - startTime);\n      //   return quads;\n      // }\n\n\n    };\n  }), _defineProperty(_ShExUtil2, \"makeQueryDB\", function makeQueryDB(endpoint, queryTracker) {\n    var _ShExUtil = this;\n\n    function getQuads(s, p, o, g) {\n      return mapQueryToTriples(\"SELECT \" + [s ? \"\" : \"?s\", p ? \"\" : \"?p\", o ? \"\" : \"?o\", \"{\", s ? s : \"?s\", p ? p : \"?s\", o ? o : \"?s\", \"}\"].join(\" \"), s, o);\n    }\n\n    function mapQueryToTriples(query, s, o) {\n      var rows = _ShExUtil.executeQuery(query, endpoint);\n\n      var triples = rows.map(function (row) {\n        return s ? {\n          subject: s,\n          predicate: row[0],\n          object: row[1]\n        } : {\n          subject: row[0],\n          predicate: row[1],\n          object: o\n        };\n      });\n      return triples;\n    }\n\n    function getTripleConstraints(tripleExpr) {\n      var visitor = _ShExUtil.Visitor();\n\n      var ret = {\n        out: [],\n        inc: []\n      };\n\n      visitor.visitTripleConstraint = function (expr) {\n        ret[expr.inverse ? \"inc\" : \"out\"].push(expr);\n        return expr;\n      };\n\n      if (tripleExpr) visitor.visitExpression(tripleExpr);\n      return ret;\n    }\n\n    function getNeighborhood(point, shapeLabel, shape) {\n      // I'm guessing a local DB doesn't benefit from shape optimization.\n      var startTime;\n      var tcs = getTripleConstraints(shape.expression);\n      var pz = tcs.out.map(function (t) {\n        return t.predicate;\n      });\n      pz = pz.filter(function (p, idx) {\n        return pz.lastIndexOf(p) === idx;\n      });\n\n      if (queryTracker) {\n        startTime = new Date();\n        queryTracker.start(false, point, shapeLabel);\n      }\n\n      var outgoing = tcs.out.length > 0 || shape.closed ? mapQueryToTriples(shape.closed ? \"SELECT ?p ?o { <\".concat(point, \"> ?p ?o }\") : \"SELECT ?p ?o {\\n\" + pz.map(function (p) {\n        return \"  {<\".concat(point, \"> <\").concat(p, \"> ?o BIND(<\").concat(p, \"> AS ?p)}\");\n      }).join(\" UNION\\n\") + \"\\n}\", point, null) : [];\n\n      if (queryTracker) {\n        var time = new Date();\n        queryTracker.end(outgoing, time - startTime);\n        startTime = time;\n      }\n\n      if (queryTracker) {\n        queryTracker.start(true, point, shapeLabel);\n      }\n\n      var incoming = tcs.inc.length > 0 ? mapQueryToTriples(\"SELECT ?s ?p { ?s ?p <\".concat(point, \"> }\"), null, point) : [];\n\n      if (queryTracker) {\n        queryTracker.end(incoming, new Date() - startTime);\n      }\n\n      return {\n        outgoing: outgoing,\n        incoming: incoming\n      };\n    }\n\n    return {\n      getNeighborhood: getNeighborhood,\n      getQuads: getQuads,\n      getSubjects: function getSubjects() {\n        return [\"!Query DB can't index subjects\"];\n      },\n      getPredicates: function getPredicates() {\n        return [\"!Query DB can't index predicates\"];\n      },\n      getObjects: function getObjects() {\n        return [\"!Query DB can't index objects\"];\n      },\n\n      get size() {\n        return undefined;\n      }\n\n    };\n  }), _defineProperty(_ShExUtil2, \"makeTriplesDB\", function makeTriplesDB(queryTracker) {\n    var _ShExUtil = this;\n\n    var incoming = [];\n    var outgoing = [];\n\n    function getTriplesByIRI(s, p, o, g) {\n      return incoming.concat(outgoing).filter(function (t) {\n        return (!s || s === t.subject) && (!p || p === t.predicate) && (!s || s === t.object);\n      });\n    }\n\n    function getNeighborhood(point, shapeLabel, shape) {\n      return {\n        outgoing: outgoing,\n        incoming: incoming\n      };\n    }\n\n    return {\n      getNeighborhood: getNeighborhood,\n      getTriplesByIRI: getTriplesByIRI,\n      getSubjects: function getSubjects() {\n        return [\"!Triples DB can't index subjects\"];\n      },\n      getPredicates: function getPredicates() {\n        return [\"!Triples DB can't index predicates\"];\n      },\n      getObjects: function getObjects() {\n        return [\"!Triples DB can't index objects\"];\n      },\n\n      get size() {\n        return undefined;\n      },\n\n      addIncomingTriples: function addIncomingTriples(tz) {\n        Array.prototype.push.apply(incoming, tz);\n      },\n      addOutgoingTriples: function addOutgoingTriples(tz) {\n        Array.prototype.push.apply(outgoing, tz);\n      }\n    };\n  }), _defineProperty(_ShExUtil2, \"NotSupplied\", \"-- not supplied --\"), _defineProperty(_ShExUtil2, \"UnknownIRI\", \"-- not found --\"), _defineProperty(_ShExUtil2, \"_expect\", function _expect(o, p, v) {\n    if (!(p in o)) this._error(\"expected \" + JSON.stringify(o) + \" to have a .\" + p);\n    if (arguments.length > 2 && o[p] !== v) this._error(\"expected \" + o[o] + \" to equal .\" + v);\n  }), _defineProperty(_ShExUtil2, \"_error\", function _error(str) {\n    throw new Error(str);\n  }), _defineProperty(_ShExUtil2, \"unescapeText\", function unescapeText(string, replacements) {\n    var regex = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\(.)/g;\n\n    try {\n      string = string.replace(regex, function (sequence, unicode4, unicode8, escapedChar) {\n        var charCode;\n\n        if (unicode4) {\n          charCode = parseInt(unicode4, 16);\n          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance\n\n          return String.fromCharCode(charCode);\n        } else if (unicode8) {\n          charCode = parseInt(unicode8, 16);\n          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance\n\n          if (charCode < 0xFFFF) return String.fromCharCode(charCode);\n          return String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));\n        } else {\n          var replacement = replacements[escapedChar];\n          if (!replacement) throw new Error(\"no replacement found for '\" + escapedChar + \"'\");\n          return replacement;\n        }\n      });\n      return string;\n    } catch (error) {\n      console.warn(error);\n      return '';\n    }\n  }), _ShExUtil2);\n\n  function n3ify(ldterm) {\n    if (typeof ldterm !== \"object\") return ldterm;\n    var ret = \"\\\"\" + ldterm.value + \"\\\"\";\n    if (\"language\" in ldterm) return ret + \"@\" + ldterm.language;\n    if (\"type\" in ldterm) return ret + \"^^\" + ldterm.type;\n    return ret;\n  } // Add the ShExUtil functions to the given object or its prototype\n\n\n  function AddShExUtil(parent, toPrototype) {\n    for (var name in ShExUtil) {\n      if (!toPrototype) parent[name] = ShExUtil[name];else parent.prototype[name] = ApplyToThis(ShExUtil[name]);\n    }\n\n    return parent;\n  } // Returns a function that applies `f` to the `this` object\n\n\n  function ApplyToThis(f) {\n    return function (a) {\n      return f(this, a);\n    };\n  }\n\n  return AddShExUtil(AddShExUtil);\n}();\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') module.exports = ShExUtil; // node environment","map":null,"metadata":{},"sourceType":"script"}