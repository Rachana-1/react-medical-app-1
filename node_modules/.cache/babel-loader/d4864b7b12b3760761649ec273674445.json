{"ast":null,"code":"var _slicedToArray = require(\"D:\\\\Downloads\\\\Test HTML\\\\react-medical-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\n/* ShExValidator - javascript module to validate a graph with respect to Shape Expressions\n *\n * Status: 1/2 tested, no known bugs.\n *\n * TODO:\n *   constraint violation reporting.\n */\nvar ShExValidator = function () {\n  var UNBOUNDED = -1; // interface constants\n\n  var Start = {\n    term: \"START\"\n  };\n  var InterfaceOptions = {\n    \"or\": {\n      \"oneOf\": \"exactly one disjunct must pass\",\n      \"someOf\": \"one or more disjuncts must pass\",\n      \"firstOf\": \"disjunct evaluation stops after one passes\"\n    },\n    \"partition\": {\n      \"greedy\": \"each triple constraint consumes all triples matching predicate and object\",\n      \"exhaustive\": \"search all mappings of triples to triple constriant\"\n    }\n  };\n  var VERBOSE = (\"VERBOSE\" in process.env); // **ShExValidator** provides ShEx utility functions\n\n  var ProgramFlowError = {\n    type: \"ProgramFlowError\",\n    errors: {\n      type: \"UntrackedError\"\n    }\n  };\n\n  var RdfTerm = require(\"./RdfTerm\");\n\n  var ShExUtil = require(\"./ShExUtil\");\n\n  var ShExWriter = require(\"../lib/ShExWriter\");\n\n  var Hierarchy = require('hierarchy-closure');\n\n  function getLexicalValue(term) {\n    return RdfTerm.isIRI(term) ? term : RdfTerm.isLiteral(term) ? RdfTerm.getLiteralValue(term) : term.substr(2); // bnodes start with \"_:\"\n  }\n\n  var XSD = \"http://www.w3.org/2001/XMLSchema#\";\n  var integerDatatypes = [XSD + \"integer\", XSD + \"nonPositiveInteger\", XSD + \"negativeInteger\", XSD + \"long\", XSD + \"int\", XSD + \"short\", XSD + \"byte\", XSD + \"nonNegativeInteger\", XSD + \"unsignedLong\", XSD + \"unsignedInt\", XSD + \"unsignedShort\", XSD + \"unsignedByte\", XSD + \"positiveInteger\"];\n  var decimalDatatypes = [XSD + \"decimal\"].concat(integerDatatypes);\n  var numericDatatypes = [XSD + \"float\", XSD + \"double\"].concat(decimalDatatypes);\n  var numericParsers = {};\n\n  numericParsers[XSD + \"integer\"] = function (label, parseError) {\n    if (!label.match(/^[+-]?[0-9]+$/)) {\n      parseError(\"illegal integer value '\" + label + \"'\");\n    }\n\n    return parseInt(label);\n  };\n\n  numericParsers[XSD + \"decimal\"] = function (label, parseError) {\n    if (!label.match(/^[+-]?(?:[0-9]*\\.[0-9]+|[0-9]+)$/)) {\n      // XSD has no pattern for decimal?\n      parseError(\"illegal decimal value '\" + label + \"'\");\n    }\n\n    return parseFloat(label);\n  };\n\n  var DECIMAL_REGEX = /^[+\\-]?(?:[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+)(?:[eE][+\\-]?[0-9]+)?$/;\n\n  numericParsers[XSD + \"float\"] = function (label, parseError) {\n    if (label === \"NaN\") return NaN;\n    if (label === \"INF\") return Infinity;\n    if (label === \"-INF\") return -Infinity;\n\n    if (!label.match(DECIMAL_REGEX)) {\n      // XSD has no pattern for float?\n      parseError(\"illegal float value '\" + label + \"'\");\n    }\n\n    return parseFloat(label);\n  };\n\n  numericParsers[XSD + \"double\"] = function (label, parseError) {\n    if (label === \"NaN\") return NaN;\n    if (label === \"INF\") return Infinity;\n    if (label === \"-INF\") return -Infinity;\n\n    if (!label.match(DECIMAL_REGEX)) {\n      parseError(\"illegal double value '\" + label + \"'\");\n    }\n\n    return Number(label);\n  };\n\n  testRange = function testRange(value, datatype, parseError) {\n    var ranges = {\n      //    integer            -1 0 1 +1 | \"\" -1.0 +1.0 1e0 NaN INF\n      //    decimal            -1 0 1 +1 -1.0 +1.0 | \"\" 1e0 NaN INF\n      //    float              -1 0 1 +1 -1.0 +1.0 1e0 1E0 NaN INF -INF | \"\" +INF\n      //    double             -1 0 1 +1 -1.0 +1.0 1e0 1E0 NaN INF -INF | \"\" +INF\n      //    nonPositiveInteger -1 0 +0 -0 | 1 +1 1a a1\n      //    negativeInteger    -1 | 0 +0 -0 1\n      //    long               -1 0 1 +1 |\n      //    int                -1 0 1 +1 |\n      //    short              -32768 0 32767 | -32769 32768\n      //    byte               -128 0 127 | \"\" -129 128\n      //    nonNegativeInteger 0 -0 +0 1 +1 | -1\n      //    unsignedLong       0 1 | -1\n      //    unsignedInt        0 1 | -1\n      //    unsignedShort      0 65535 | -1 65536\n      //    unsignedByte       0 255 | -1 256\n      //    positiveInteger    1 | -1 0\n      //    string             \"\" \"a\" \"0\"\n      //    boolean            true false 0 1 | \"\" TRUE FALSE tRuE fAlSe -1 2 10 01\n      //    dateTime           \"2012-01-02T12:34:56.78Z\" | \"\" \"2012-01-02T\" \"2012-01-02\"\n      integer: {\n        min: -Infinity,\n        max: Infinity\n      },\n      decimal: {\n        min: -Infinity,\n        max: Infinity\n      },\n      float: {\n        min: -Infinity,\n        max: Infinity\n      },\n      double: {\n        min: -Infinity,\n        max: Infinity\n      },\n      nonPositiveInteger: {\n        min: -Infinity,\n        max: 0\n      },\n      negativeInteger: {\n        min: -Infinity,\n        max: -1\n      },\n      long: {\n        min: -9223372036854775808,\n        max: 9223372036854775807\n      },\n      int: {\n        min: -2147483648,\n        max: 2147483647\n      },\n      short: {\n        min: -32768,\n        max: 32767\n      },\n      byte: {\n        min: -128,\n        max: 127\n      },\n      nonNegativeInteger: {\n        min: 0,\n        max: Infinity\n      },\n      unsignedLong: {\n        min: 0,\n        max: 18446744073709551615\n      },\n      unsignedInt: {\n        min: 0,\n        max: 4294967295\n      },\n      unsignedShort: {\n        min: 0,\n        max: 65535\n      },\n      unsignedByte: {\n        min: 0,\n        max: 255\n      },\n      positiveInteger: {\n        min: 1,\n        max: Infinity\n      }\n    };\n    var parms = ranges[datatype.substr(XSD.length)];\n    if (!parms) throw Error(\"unexpected datatype: \" + datatype);\n\n    if (value < parms.min) {\n      parseError(\"\\\"\" + value + \"\\\"^^<\" + datatype + \"> is less than the min:\", parms.min);\n    } else if (value > parms.max) {\n      parseError(\"\\\"\" + value + \"\\\"^^<\" + datatype + \"> is greater than the max:\", parms.min);\n    }\n  };\n  /*\n  function intSubType (spec, label, parseError) {\n    var ret = numericParsers[XSD + \"integer\"](label, parseError);\n    if (\"min\" in spec && ret < spec.min)\n      parseError(\"illegal \" + XSD + spec.type + \" value '\" + label + \"' should not be < \" + spec.min);\n    if (\"max\" in spec && ret > spec.max)\n      parseError(\"illegal \" + XSD + spec.type + \" value '\" + label + \"' should not be > \" + spec.max);\n    return ret;\n  }\n  [{type: \"nonPositiveInteger\", max: 0},\n   {type: \"negativeInteger\", max: -1},\n   {type: \"long\", min: -9223372036854775808, max: 9223372036854775807}, // beyond IEEE double\n   {type: \"int\", min: -2147483648, max: 2147483647},\n   {type: \"short\", min: -32768, max: 32767},\n   {type: \"byte\", min: -128, max: 127},\n   {type: \"nonNegativeInteger\", min: 0},\n   {type: \"unsignedLong\", min: 0, max: 18446744073709551615},\n   {type: \"unsignedInt\", min: 0, max: 4294967295},\n   {type: \"unsignedShort\", min: 0, max: 65535},\n   {type: \"unsignedByte\", min: 0, max: 255},\n   {type: \"positiveInteger\", min: 1}].forEach(function (i) {\n     numericParsers[XSD + i.type ] = function (label, parseError) {\n       return intSubType(i, label, parseError);\n     };\n   });\n  */\n\n\n  var stringTests = {\n    length: function length(v, l) {\n      return v.length === l;\n    },\n    minlength: function minlength(v, l) {\n      return v.length >= l;\n    },\n    maxlength: function maxlength(v, l) {\n      return v.length <= l;\n    }\n  };\n  var numericValueTests = {\n    mininclusive: function mininclusive(n, m) {\n      return n >= m;\n    },\n    minexclusive: function minexclusive(n, m) {\n      return n > m;\n    },\n    maxinclusive: function maxinclusive(n, m) {\n      return n <= m;\n    },\n    maxexclusive: function maxexclusive(n, m) {\n      return n < m;\n    }\n  };\n  var decimalLexicalTests = {\n    totaldigits: function totaldigits(v, d) {\n      var m = v.match(/[0-9]/g);\n      return m && m.length <= d;\n    },\n    fractiondigits: function fractiondigits(v, d) {\n      var m = v.match(/^[+-]?[0-9]*\\.?([0-9]*)$/);\n      return m && m[1].length <= d;\n    }\n  };\n\n  function ldify(term) {\n    if (term[0] !== \"\\\"\") return term;\n    var ret = {\n      value: RdfTerm.getLiteralValue(term)\n    };\n    var dt = RdfTerm.getLiteralType(term);\n    if (dt && dt !== \"http://www.w3.org/2001/XMLSchema#string\" && dt !== \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\") ret.type = dt;\n    var lang = RdfTerm.getLiteralLanguage(term);\n    if (lang) ret.language = lang;\n    return ret;\n  }\n\n  function isTerm(t) {\n    return typeof t !== \"object\" || \"value\" in t && Object.keys(t).reduce(function (r, k) {\n      return r === false ? r : [\"value\", \"type\", \"language\"].indexOf(k) !== -1;\n    }, true);\n  }\n  /* ShExValidator_constructor - construct an object for validating a schema.\n   *\n   * schema: a structure produced by a ShEx parser or equivalent.\n   * options: object with controls for\n   *   lax(true): boolean: whine about missing types in schema.\n   *   diagnose(false): boolean: makde validate return a structure with errors.\n   */\n\n\n  function ShExValidator_constructor(schema, options) {\n    if (!(this instanceof ShExValidator_constructor)) return new ShExValidator_constructor(schema, options);\n    var index = schema._index || ShExUtil.index(schema);\n    this.type = \"ShExValidator\";\n    options = options || {};\n    this.options = options;\n    this.options.or = this.options.or || \"someOf\";\n    this.options.partition = this.options.partition || \"exhaustive\";\n    if (!(\"noCache\" in options && options.noCache)) this.known = {};\n\n    var _ShExValidator = this;\n\n    this.schema = schema;\n    this._expect = this.options.lax ? noop : expect; // report errors on missing types.\n\n    this._optimize = {}; // optimizations:\n    // hasRepeatedGroups: whether there are patterns like (:p1 ., :p2 .)*\n\n    this.reset = function () {}; // included in case we need it later.\n    // var regexModule = this.options.regexModule || require(\"../lib/regex/nfax-val-1err\");\n\n\n    var regexModule = this.options.regexModule || require(\"../lib/regex/threaded-val-nerr\");\n    /* getAST - compile a traditional regular expression abstract syntax tree.\n     * Tested but not used at present.\n     */\n\n\n    this.getAST = function () {\n      return {\n        type: \"AST\",\n        shapes: schema.shapes.reduce(function (ret, shape) {\n          ret[shape.id] = {\n            type: \"ASTshape\",\n            expression: _compileShapeToAST(shape.expression, [], _ShExValidator.schema)\n          };\n          return ret;\n        }, {})\n      };\n    };\n    /* indexTripleConstraints - compile regular expression and index triple constraints\n     */\n\n\n    this.indexTripleConstraints = function (expression) {\n      // list of triple constraints from (:p1 ., (:p2 . | :p3 .))\n      var tripleConstraints = [];\n      if (expression) indexTripleConstraints_dive(expression);\n      return tripleConstraints;\n\n      function indexTripleConstraints_dive(expr) {\n        if (typeof expr === \"string\") // Inclusion\n          return record(indexTripleConstraints_dive(index.tripleExprs[expr]));else if (expr.type === \"TripleConstraint\") {\n          tripleConstraints.push(expr);\n          return record([tripleConstraints.length - 1]); // index of expr\n        } else if (expr.type === \"OneOf\" || expr.type === \"EachOf\") return record(expr.expressions.reduce(function (acc, nested) {\n          return acc.concat(indexTripleConstraints_dive(nested));\n        }, []));else if (expr.type === \"NestedShape\") return [];else runtimeError(\"unexpected expr type: \" + expr.type);\n\n        function record(tcs) {\n          if (typeof expr !== \"string\" && \"onShapeExpression\" in expr) // !ShapeRef\n            expr.scopedTripleConstraints = tcs;\n          return tcs;\n        }\n      }\n\n      ;\n    };\n    /* emptyTracker - a tracker that does nothing\n     */\n\n\n    this.emptyTracker = function () {\n      var noop = function noop(x) {\n        return x;\n      };\n\n      return {\n        recurse: noop,\n        known: noop,\n        enter: function enter(point, label) {\n          ++this.depth;\n        },\n        exit: function exit(point, label, ret) {\n          --this.depth;\n        },\n        depth: 0\n      };\n    };\n    /* validate - test point in db against the schema for labelOrShape\n     * depth: level of recurssion; for logging.\n     */\n\n\n    this.validate = function (db, point, label, tracker, seen, subGraph) {\n      var _this = this;\n\n      // default to schema's start shape\n      if (typeof point === \"object\" && \"termType\" in point) {\n        point = RdfTerm.internalTerm(point);\n      }\n\n      if (typeof point === \"object\") {\n        var shapeMap = point;\n\n        if (this.options.results === \"api\") {\n          return shapeMap.map(function (pair) {\n            var time = new Date();\n\n            var res = _this.validate(db, pair.node, pair.shape, label, tracker); // really tracker and seen\n\n\n            time = new Date() - time;\n            return {\n              node: pair.node,\n              shape: pair.shape,\n              status: \"errors\" in res ? \"nonconformant\" : \"conformant\",\n              appinfo: res,\n              elapsed: time\n            };\n          });\n        }\n\n        var results = shapeMap.reduce(function (ret, pair) {\n          var res = _this.validate(db, pair.node, pair.shape, label, tracker, subGraph); // really tracker and seen\n\n\n          return \"errors\" in res ? {\n            passes: ret.passes,\n            failures: ret.failures.concat(res)\n          } : {\n            passes: ret.passes.concat(res),\n            failures: ret.failures\n          };\n        }, {\n          passes: [],\n          failures: []\n        });\n\n        if (false && this.options.results === \"api\") {\n          var _add = function _add(n, s, r) {\n            if (!(n in ret)) {\n              ret[n] = [{\n                shape: s,\n                result: r\n              }];\n              return;\n            }\n\n            if (ret[n].filter(function (p) {\n              return p.shape === s;\n            })) return;\n            ret[n].push({\n              shape: s,\n              results: r\n            });\n          };\n\n          var ret = {};\n          results.passes.forEach(function (p) {\n            _add(p.node, p.shape, true);\n          });\n          results.failures.forEach(function (p) {\n            _add(p.node, p.shape, false);\n          });\n          return ret;\n        }\n\n        if (results.failures.length > 0) {\n          return results.failures.length !== 1 ? {\n            type: \"FailureList\",\n            errors: results.failures\n          } : results.failures[0];\n        } else {\n          return results.passes.length !== 1 ? {\n            type: \"SolutionList\",\n            solutions: results.passes\n          } : results.passes[0];\n        }\n      }\n\n      var outside = tracker === undefined; // logging stuff\n\n      if (!tracker) tracker = this.emptyTracker();\n\n      if (!label || label === Start) {\n        if (!schema.start) runtimeError(\"start production not defined\");\n      }\n\n      var shape = null;\n\n      if (label == Start) {\n        shape = schema.start;\n      } else if (!(\"shapes\" in this.schema) || this.schema.shapes.length === 0) {\n        runtimeError(\"shape \" + label + \" not found; no shapes in schema\");\n      } else if (label in index.shapeExprs) {\n        shape = index.shapeExprs[label];\n      } else {\n        runtimeError(\"shape \" + label + \" not found in:\\n\" + Object.keys(index.shapeExprs || []).map(function (s) {\n          return \"  \" + s;\n        }).join(\"\\n\"));\n      }\n\n      if (typeof label !== \"string\") return this._validateShapeDecl(db, point, shape, Start, 0, tracker, seen);\n      if (seen === undefined) seen = {};\n      var seenKey = point + \"@\" + (label === Start ? \"_: -start-\" : label);\n\n      if (!subGraph) {\n        if (seenKey in seen) return tracker.recurse({\n          type: \"Recursion\",\n          node: ldify(point),\n          shape: label\n        });\n        if (\"known\" in this && seenKey in this.known) return tracker.known(this.known[seenKey]);\n        seen[seenKey] = {\n          point: point,\n          shape: label\n        };\n        tracker.enter(point, label);\n      }\n\n      function schemaExtensions(schema) {\n        var abstractness = {};\n        var extensions = Hierarchy.create();\n        makeSchemaVisitor().visitSchema(schema);\n        return extensions.children;\n\n        function makeSchemaVisitor(schema) {\n          var schemaVisitor = ShExUtil.Visitor();\n          var curLabel;\n          var curAbstract;\n          var oldVisitShapeDecl = schemaVisitor.visitShapeDecl;\n\n          schemaVisitor.visitShapeDecl = function (decl) {\n            curLabel = decl.id;\n            curAbstract = decl.abstract;\n            abstractness[decl.id] = decl.abstract;\n            return oldVisitShapeDecl.call(schemaVisitor, decl, decl.id);\n          };\n\n          var oldVisitShape = schemaVisitor.visitShape;\n\n          schemaVisitor.visitShape = function (shape) {\n            if (\"extends\" in shape) {\n              shape.extends.forEach(function (ext) {\n                var extendsVisitor = ShExUtil.Visitor();\n\n                extendsVisitor.visitShapeRef = function (parent) {\n                  extensions.add(parent, curLabel); // makeSchemaVisitor().visitSchema(schema);\n\n                  return \"null\";\n                };\n\n                extendsVisitor.visitShapeExpr(ext);\n              });\n            }\n\n            return \"null\";\n          };\n\n          return schemaVisitor;\n        }\n      } // Get derived shapes.\n\n\n      var candidates = [label];\n\n      if (!subGraph) {\n        candidates = candidates.concat(schemaExtensions(this.schema)[label] || []); // Uniquify list.\n\n        for (var i = candidates.length - 1; i >= 0; --i) {\n          if (candidates.indexOf(candidates[i]) < i) candidates.splice(i, 1);\n        } // Filter out abstract shapes.\n\n\n        candidates = candidates.filter(function (l) {\n          return !index.shapeExprs[l].abstract;\n        });\n      }\n\n      var results = candidates.reduce(function (ret, label) {\n        var shapeExpr = index.shapeExprs[label];\n\n        var res = _this._validateShapeDecl(db, point, shapeExpr, label, 0, tracker, seen, subGraph);\n\n        return \"errors\" in res ? {\n          passes: ret.passes,\n          failures: ret.failures.concat(res)\n        } : {\n          passes: ret.passes.concat(res),\n          failures: ret.failures\n        };\n      }, {\n        passes: [],\n        failures: []\n      });\n      var ret;\n\n      if (results.passes.length > 0) {\n        ret = results.passes.length !== 1 ? {\n          type: \"SolutionList\",\n          solutions: results.passes\n        } : results.passes[0];\n      } else if (results.failures.length > 0) {\n        ret = results.failures.length !== 1 ? {\n          type: \"FailureList\",\n          errors: results.failures\n        } : results.failures[0];\n      } else {\n        ret = {\n          type: \"AbstractShapeFailure\",\n          shape: label,\n          errors: label + \" has no non-abstract children\"\n        };\n      }\n\n      if (!subGraph) {\n        tracker.exit(point, label, ret);\n        delete seen[seenKey]; // Don't cache EXTENDS validations as they aren't testing the neighborhood.\n\n        if (\"known\" in this) this.known[seenKey] = ret;\n      }\n\n      if (\"startActs\" in schema && outside) {\n        ret.startActs = schema.startActs;\n      }\n\n      return ret;\n    };\n\n    this._validateShapeDecl = function (db, point, shapeExpr, shapeLabel, depth, tracker, seen, subgraph) {\n      var expr = shapeExpr.type === \"ShapeDecl\" ? shapeExpr.shapeExpr : shapeExpr;\n      return this._validateShapeExpr(db, point, expr, shapeLabel, depth, tracker, seen, subgraph);\n    };\n\n    this._validateShapeExpr = function (db, point, shapeExpr, shapeLabel, depth, tracker, seen, subgraph) {\n      if (point === \"\") throw Error(\"validation needs a valid focus node\");\n\n      if (typeof shapeExpr === \"string\") {\n        // ShapeRef\n        return this._validateShapeDecl(db, point, index.shapeExprs[shapeExpr], shapeExpr, depth, tracker, seen, subgraph);\n      } else if (shapeExpr.type === \"NodeConstraint\") {\n        var sub = this._errorsMatchingNodeConstraint(point, shapeExpr, null);\n\n        return sub.errors && sub.errors.length ? {\n          type: \"Failure\",\n          node: ldify(point),\n          shape: shapeLabel,\n          errors: sub.errors.map(function (error) {\n            // !!! just sub.errors?\n            return {\n              type: \"NodeConstraintViolation\",\n              shapeExpr: shapeExpr,\n              error: error\n            };\n          })\n        } : {\n          type: \"NodeTest\",\n          node: ldify(point),\n          shape: shapeLabel,\n          shapeExpr: shapeExpr\n        };\n      } else if (shapeExpr.type === \"Shape\") {\n        return this._validateShape(db, point, shapeExpr, shapeLabel, depth, tracker, seen, subgraph); // return this._validateShape(db, point, regexModule.compile(schema, shapeExpr, index),\n        //                            shapeExpr, shapeLabel, tracker, seen);\n      } else if (shapeExpr.type === \"ShapeExternal\") {\n        return this.options.validateExtern(db, point, shapeLabel, tracker, seen);\n      } else if (shapeExpr.type === \"ShapeOr\") {\n        var errors = [];\n\n        for (var i = 0; i < shapeExpr.shapeExprs.length; ++i) {\n          var nested = shapeExpr.shapeExprs[i];\n\n          var sub = this._validateShapeExpr(db, point, nested, shapeLabel, depth, tracker, seen, subgraph);\n\n          if (\"errors\" in sub) errors.push(sub);else return {\n            type: \"ShapeOrResults\",\n            solution: sub\n          };\n        }\n\n        return {\n          type: \"ShapeOrFailure\",\n          errors: errors\n        };\n      } else if (shapeExpr.type === \"ShapeNot\") {\n        var sub = this._validateShapeExpr(db, point, shapeExpr.shapeExpr, shapeLabel, depth, tracker, seen, subgraph);\n\n        if (\"errors\" in sub) return {\n          type: \"ShapeNotResults\",\n          solution: sub\n        };else return {\n          type: \"ShapeNotFailure\",\n          errors: sub\n        };\n      } else if (shapeExpr.type === \"ShapeAnd\") {\n        var passes = [];\n        var errors = [];\n\n        for (var i = 0; i < shapeExpr.shapeExprs.length; ++i) {\n          var nested = shapeExpr.shapeExprs[i];\n\n          var sub = this._validateShapeExpr(db, point, nested, shapeLabel, depth, tracker, seen, subgraph);\n\n          if (\"errors\" in sub) errors.push(sub);else passes.push(sub);\n        }\n\n        if (errors.length > 0) {\n          return {\n            type: \"ShapeAndFailure\",\n            errors: errors\n          };\n        }\n\n        return {\n          type: \"ShapeAndResults\",\n          solutions: passes\n        };\n      } else throw Error(\"expected one of Shape{Ref,And,Or} or NodeConstraint, got \" + JSON.stringify(shapeExpr));\n    };\n\n    this._validateShape = function (db, point, shape, shapeLabel, depth, tracker, seen, subgraph) {\n      var _ShExValidator = this;\n\n      var valParms = {\n        db: db,\n        shapeLabel: shapeLabel,\n        depth: depth,\n        tracker: tracker,\n        seen: seen\n      };\n      var extendedTCs = []; // TCs found in the extends\n\n      var constraintToExtends = []; // map from TC to list of extends\n\n      effectiveShapeExpression(shape, extendedTCs, constraintToExtends); // var tempShape = new ShExWriter({simplifyParentheses: true})._writeShapeExpr(effectiveExpr).join('');\n      // console.log(JSON.stringify(effectiveExpr, null, 2))\n      // console.log(tempShape)\n      // var tempSchema = {type:\"Schema\", shapes: {}}; tempSchema.shapes[labelOrShape] = effectiveExpr;\n      // new ShEx.Writer().writeSchema(tempSchema, function (error, text, prefixes) { console.log(text) })\n\n      var ret = null;\n      var startAcionStorage = {}; // !!! need test to see this write to results structure.\n\n      if (\"startActs\" in schema) {\n        var semActErrors = this.semActHandler.dispatchAll(schema.startActs, null, startAcionStorage);\n        if (semActErrors.length) return {\n          type: \"Failure\",\n          node: ldify(point),\n          shape: shapeLabel,\n          errors: semActErrors\n        }; // some semAct aborted !! return real error\n      } // @@ add to tracker: f(\"validating <\" + point + \"> as <\" + shapeLabel + \">\");\n\n\n      var fromDB = (subgraph || db).getNeighborhood(point, shapeLabel, shape);\n      var outgoing = indexNeighborhood(fromDB.outgoing.sort(function (l, r) {\n        return l.predicate.localeCompare(r.predicate) || sparqlOrder(l.object, r.object);\n      }));\n      var incoming = indexNeighborhood(fromDB.incoming.sort(function (l, r) {\n        return l.predicate.localeCompare(r.predicate) || sparqlOrder(l.subject, r.subject);\n      }));\n      var outgoingLength = fromDB.outgoing.length;\n      var neighborhood = fromDB.outgoing.concat(fromDB.incoming);\n      var localTCs = this.indexTripleConstraints(shape.expression);\n      var constraintList = extendedTCs.concat(localTCs); // !! adds tcis to shape.expression\n\n      var tripleList = constraintList.reduce(function (ret, constraint, cNo) {\n        // subject and object depend on direction of constraint.\n        var searchSubject = constraint.inverse ? null : point;\n        var searchObject = constraint.inverse ? point : null;\n        var index = constraint.inverse ? incoming : outgoing; // get triples matching predciate\n\n        var matchPredicate = index.byPredicate[constraint.predicate] || []; // empty list when no triple matches that constraint\n        // strip to triples matching value constraints (apart from @<someShape>)\n\n        var matchConstraints = _ShExValidator._triplesMatchingShapeExpr(matchPredicate, constraint, valParms);\n\n        matchConstraints.hits.forEach(function (evidence) {\n          var tNo = neighborhood.indexOf(evidence.triple);\n          ret.constraintList[tNo].push(cNo);\n          ret.results[cNo][tNo] = evidence.sub;\n        });\n        matchConstraints.misses.forEach(function (evidence) {\n          var tNo = neighborhood.indexOf(evidence.triple);\n          ret.misses[tNo] = {\n            constraintNo: cNo,\n            errors: evidence.errors\n          };\n        });\n        return ret;\n      }, {\n        misses: {},\n        results: _alist(constraintList.length),\n        constraintList: _alist(neighborhood.length)\n      }); // start with [[],[]...]\n      // @@ add to tracker: f(\"constraints by triple: \", JSON.stringify(tripleList.constraintList));\n\n      var extras = []; // triples accounted for by EXTRA\n\n      var misses = tripleList.constraintList.reduce(function (ret, constraints, ord) {\n        if (constraints.length === 0 && // matches no constraints\n        ord < outgoingLength && // not an incoming triple\n        ord in tripleList.misses) {\n          // predicate matched some constraint(s)\n          if (shape.extra !== undefined && shape.extra.indexOf(neighborhood[ord].predicate) !== -1) {\n            extras.push(ord);\n          } else {\n            // not declared extra\n            ret.push({\n              // so it's a missed triple.\n              tripleNo: ord,\n              constraintNo: tripleList.misses[ord].constraintNo,\n              errors: tripleList.misses[ord].errors\n            });\n          }\n        }\n\n        return ret;\n      }, []);\n      var xp = crossProduct(tripleList.constraintList);\n      var partitionErrors = [];\n      var regexEngine = regexModule.compile(schema, shape, index);\n\n      while ((misses.length === 0 || this.options.partition !== \"greedy\") && xp.next() && ret === null) {\n        // Pivot to triples by constraint.\n        var _constraintToTriples = function _constraintToTriples() {\n          return tripleToConstraintMapping.slice().reduce(function (ret, cNo, tNo) {\n            if (cNo !== undefined) ret[cNo].push({\n              tNo: tNo,\n              res: tripleList.results[cNo][tNo]\n            });\n            return ret;\n          }, _seq(constraintList.length).map(function () {\n            return [];\n          })); // [length][]\n        };\n\n        // alts.push(tripleToConstraintMapping);\n        var passScoped = function passScoped(expr, extendsToTriples, valParms) {\n          if (!(\"extends\" in expr)) return null;\n          var passes = [];\n\n          for (var eNo = 0; eNo < expr.extends.length; ++eNo) {\n            var extend = expr.extends[eNo];\n            var subgraph = ShExUtil.makeTriplesDB(null); // These triples were tracked earlier.\n\n            extendsToTriples[eNo].forEach(function (t) {\n              return subgraph.addOutgoingTriples([t]);\n            });\n\n            var sub = _ShExValidator._errorsMatchingShapeExpr(point, extend, valParms, subgraph);\n\n            if (\"errors\" in sub) return {\n              type: \"ExtensionFailure\",\n              errors: [sub]\n            };else passes.push(sub);\n          }\n\n          return {\n            type: \"ExtensionResults\",\n            solutions: passes\n          };\n        };\n\n        // caution: early continues\n        var usedTriples = []; // [{s1,p1,o1},{s2,p2,o2}] implicated triples -- used for messages\n\n        var constraintMatchCount = // [2,1,0,1] how many triples matched a constraint\n        _seq(neighborhood.length).map(function () {\n          return 0;\n        });\n\n        var tripleToConstraintMapping0 = xp.get(); // [0,1,0,3] mapping from triple to constraint\n\n        var tripleToConstraintMapping = [];\n        var tripleToExtendsMapping = [];\n\n        var extendsToTriples = _seq((shape.extends || []).length).map(function () {\n          return [];\n        });\n\n        tripleToConstraintMapping0.forEach(function (cNo, tNo) {\n          if (cNo < extendedTCs.length) {\n            constraintToExtends[cNo].forEach(function (extNo) {\n              extendsToTriples[extNo].push(neighborhood[tNo]);\n              tripleToExtendsMapping[tNo] = cNo;\n              tripleToConstraintMapping[tNo] = undefined;\n            });\n          } else {\n            tripleToExtendsMapping[tNo] = undefined;\n            tripleToConstraintMapping[tNo] = cNo;\n          }\n        }); // Triples not mapped to triple constraints are not allowed in closed shapes.\n\n        if (shape.closed) {\n          var unexpectedTriples = neighborhood.slice(0, outgoingLength).filter(function (t, i) {\n            return tripleToExtendsMapping[i] === undefined && // didn't match an EXTENDS\n            tripleToConstraintMapping[i] === undefined && // didn't match a constraint\n            extras.indexOf(i) === -1; // wasn't in EXTRAs.\n          });\n\n          if (unexpectedTriples.length > 0) {\n            partitionErrors.push({\n              errors: [{\n                type: \"ClosedShapeViolation\",\n                unexpectedTriples: unexpectedTriples\n              }]\n            });\n            continue; // closed shape violation.\n          }\n        } // Set usedTriples and constraintMatchCount.\n\n\n        tripleToConstraintMapping.forEach(function (tpNumber, ord) {\n          if (tpNumber !== undefined) {\n            usedTriples.push(neighborhood[ord]);\n            ++constraintMatchCount[tpNumber];\n          }\n        });\n\n        var constraintToTriplesMapping = _constraintToTriples(); // e.g. [[t0, t2], [t1, t3]]\n\n\n        tripleToConstraintMapping.slice().sort(function (a, b) {\n          return a - b;\n        }).filter(function (i) {\n          // sort constraint numbers\n          return i !== undefined;\n        }).map(function (n) {\n          return n + \" \";\n        }).join(\"\"); // e.g. 0 0 1 3\n\n        var results = passScoped(shape, extendsToTriples, valParms);\n\n        if (results === null || !(\"errors\" in results)) {\n          var sub = regexEngine.match(db, point, constraintList, constraintToTriplesMapping, tripleToConstraintMapping, neighborhood, this.semActHandler, null);\n\n          if (!(\"errors\" in sub) && results) {\n            results = {\n              type: \"ExtendedResults\",\n              extensions: results\n            };\n            if (Object.keys(sub).length > 0) // no empty objects from {}s.\n              results.local = sub;\n          } else {\n            results = sub;\n          }\n        }\n\n        if (\"errors\" in results) {\n          partitionErrors.push({\n            errors: results.errors\n          });\n          if (_ShExValidator.options.partition !== \"exhaustive\") break;else continue;\n        } // @@ add to tracker: f(\"post-regexp \" + usedTriples.join(\" \"));\n\n\n        var possibleRet = {\n          type: \"ShapeTest\",\n          node: ldify(point),\n          shape: shapeLabel\n        };\n        if (Object.keys(results).length > 0) // only include .solution for non-empty pattern\n          possibleRet.solution = results;\n\n        if (\"semActs\" in shape) {\n          var _semActErrors = this.semActHandler.dispatchAll(shape.semActs, results, possibleRet);\n\n          if (_semActErrors.length) {\n            // some semAct aborted\n            partitionErrors.push({\n              errors: _semActErrors\n            });\n            if (_ShExValidator.options.partition !== \"exhaustive\") break;else continue;\n          }\n        } // @@ add to tracker: f(\"final \" + usedTriples.join(\" \"));\n\n\n        ret = possibleRet;\n        partitionErrors = [];\n      }\n\n      var missErrors = misses.map(function (miss) {\n        var t = neighborhood[miss.tripleNo];\n        return {\n          type: \"TypeMismatch\",\n          triple: {\n            type: \"TestedTriple\",\n            subject: t.subject,\n            predicate: t.predicate,\n            object: ldify(t.object)\n          },\n          constraint: constraintList[miss.constraintNo],\n          errors: miss.errors\n        };\n      });\n      var errors = missErrors.concat(partitionErrors.length === 1 ? partitionErrors[0].errors : partitionErrors);\n\n      if (errors.length > 0) {\n        ret = {\n          type: \"Failure\",\n          node: ldify(point),\n          shape: shapeLabel,\n          errors: errors\n        };\n      }\n\n      if (VERBOSE) {\n        // remove N3jsTripleToString\n        neighborhood.forEach(function (t) {\n          delete t.toString;\n        });\n      } // @@ add to tracker: f(\"</\" + shapeLabel + \">\");\n\n\n      return addShapeAttributes(ret);\n\n      function addShapeAttributes(ret) {\n        if (\"annotations\" in shape) ret.annotations = shape.annotations;\n        return ret;\n      }\n    };\n\n    this._triplesMatchingShapeExpr = function (triples, constraint, valParms) {\n      var _ShExValidator = this;\n\n      var misses = [];\n      var hits = [];\n      triples.forEach(function (triple) {\n        var value = constraint.inverse ? triple.subject : triple.object;\n        var sub;\n        var oldBindings = JSON.parse(JSON.stringify(_ShExValidator.semActHandler.results));\n        var errors = constraint.valueExpr === undefined ? undefined : (sub = _ShExValidator._errorsMatchingShapeExpr(value, constraint.valueExpr, valParms)).errors;\n\n        if (!errors) {\n          hits.push({\n            triple: triple,\n            sub: sub\n          });\n        } else if (hits.indexOf(triple) === -1) {\n          _ShExValidator.semActHandler.results = JSON.parse(JSON.stringify(oldBindings));\n          misses.push({\n            triple: triple,\n            errors: errors\n          });\n        }\n      });\n      return {\n        hits: hits,\n        misses: misses\n      };\n    };\n\n    this._errorsMatchingShapeExpr = function (value, valueExpr, valParms, subgraph) {\n      var _ShExValidator = this;\n\n      if (typeof valueExpr === \"string\") {\n        // ShapeRef\n        return _ShExValidator.validate(valParms.db, value, valueExpr, valParms.tracker, valParms.seen, subgraph);\n      } else if (valueExpr.type === \"NodeConstraint\") {\n        return this._errorsMatchingNodeConstraint(value, valueExpr, null);\n      } else if (valueExpr.type === \"Shape\") {\n        return _ShExValidator._validateShapeExpr(valParms.db, value, valueExpr, valParms.shapeLabel, valParms.depth, valParms.tracker, valParms.seen, subgraph);\n        return validateBySExpr(value, valueExpr);\n      } else if (valueExpr.type === \"ShapeOr\") {\n        var errors = [];\n\n        for (var i = 0; i < valueExpr.shapeExprs.length; ++i) {\n          var nested = valueExpr.shapeExprs[i];\n\n          var sub = _ShExValidator._errorsMatchingShapeExpr(value, nested, valParms, subgraph);\n\n          if (\"errors\" in sub) errors.push(sub);else return {\n            type: \"ShapeOrResults\",\n            solution: sub\n          };\n        }\n\n        return {\n          type: \"ShapeOrFailure\",\n          errors: errors\n        };\n      } else if (valueExpr.type === \"ShapeAnd\") {\n        var passes = [];\n\n        for (var i = 0; i < valueExpr.shapeExprs.length; ++i) {\n          var nested = valueExpr.shapeExprs[i];\n\n          var sub = _ShExValidator._errorsMatchingShapeExpr(value, nested, valParms, subgraph);\n\n          if (\"errors\" in sub) return {\n            type: \"ShapeAndFailure\",\n            errors: [sub]\n          };else passes.push(sub);\n        }\n\n        return {\n          type: \"ShapeAndResults\",\n          solutions: passes\n        };\n      } else if (valueExpr.type === \"ShapeNot\") {\n        var sub = _ShExValidator._errorsMatchingShapeExpr(value, valueExpr.shapeExpr, valParms, subgraph); // return sub.errors && sub.errors.length ? {} : {\n        //   errors: [\"Error validating \" + value + \" as \" + JSON.stringify(valueExpr) + \": expected NOT to pass\"] };\n\n\n        var ret = Object.assign({\n          type: null,\n          focus: value\n        }, valueExpr);\n\n        if (sub.errors && sub.errors.length) {\n          ret.type = \"ShapeNotTest\"; // ret = {};\n        } else {\n          ret.type = \"ShapeNotFailure\";\n          ret.errors = [\"Error validating \" + value + \" as \" + JSON.stringify(valueExpr) + \": expected NOT to pass\"];\n        }\n\n        return ret;\n      } else {\n        throw Error(\"unknown value expression type '\" + valueExpr.type + \"'\");\n      }\n    };\n    /* _errorsMatchingNodeConstraint - return whether the value matches the value\n     * expression without checking shape references.\n     */\n\n\n    this._errorsMatchingNodeConstraint = function (value, valueExpr, recurse) {\n      var errors = [];\n      var label = RdfTerm.isLiteral(value) ? RdfTerm.getLiteralValue(value) : RdfTerm.isBlank(value) ? value.substring(2) : value;\n      var dt = RdfTerm.isLiteral(value) ? RdfTerm.getLiteralType(value) : null;\n      var numeric = integerDatatypes.indexOf(dt) !== -1 ? XSD + \"integer\" : numericDatatypes.indexOf(dt) !== -1 ? dt : undefined;\n\n      function validationError() {\n        var errorStr = Array.prototype.join.call(arguments, \"\");\n        errors.push(\"Error validating \" + value + \" as \" + JSON.stringify(valueExpr) + \": \" + errorStr);\n        return false;\n      } // if (negated) ;\n\n\n      if (false) {// wildcard -- ignore\n      } else {\n        if (\"nodeKind\" in valueExpr) {\n          if ([\"iri\", \"bnode\", \"literal\", \"nonliteral\"].indexOf(valueExpr.nodeKind) === -1) {\n            validationError(\"unknown node kind '\" + valueExpr.nodeKind + \"'\");\n          }\n\n          if (RdfTerm.isBlank(value)) {\n            if (valueExpr.nodeKind === \"iri\" || valueExpr.nodeKind === \"literal\") {\n              validationError(\"blank node found when \" + valueExpr.nodeKind + \" expected\");\n            }\n          } else if (RdfTerm.isLiteral(value)) {\n            if (valueExpr.nodeKind !== \"literal\") {\n              validationError(\"literal found when \" + valueExpr.nodeKind + \" expected\");\n            }\n          } else if (valueExpr.nodeKind === \"bnode\" || valueExpr.nodeKind === \"literal\") {\n            validationError(\"iri found when \" + valueExpr.nodeKind + \" expected\");\n          }\n        }\n\n        if (valueExpr.datatype && valueExpr.values) validationError(\"found both datatype and values in \" + tripleConstraint);\n\n        if (valueExpr.datatype) {\n          if (!RdfTerm.isLiteral(value)) {\n            validationError(\"mismatched datatype: \" + value + \" is not a literal with datatype \" + valueExpr.datatype);\n          } else if (RdfTerm.getLiteralType(value) !== valueExpr.datatype) {\n            validationError(\"mismatched datatype: \" + RdfTerm.getLiteralType(value) + \" !== \" + valueExpr.datatype);\n          } else if (numeric) {\n            testRange(numericParsers[numeric](label, validationError), valueExpr.datatype, validationError);\n          } else if (valueExpr.datatype === XSD + \"boolean\") {\n            if (label !== \"true\" && label !== \"false\" && label !== \"1\" && label !== \"0\") validationError(\"illegal boolean value: \" + label);\n          } else if (valueExpr.datatype === XSD + \"dateTime\") {\n            if (!label.match(/^[+-]?\\d{4}-[01]\\d-[0-3]\\dT[0-5]\\d:[0-5]\\d:[0-5]\\d(\\.\\d+)?([+-][0-2]\\d:[0-5]\\d|Z)?$/)) validationError(\"illegal dateTime value: \" + label);\n          }\n        }\n\n        if (valueExpr.values) {\n          if (RdfTerm.isLiteral(value) && valueExpr.values.reduce(function (ret, v) {\n            if (ret) return true;\n            var ld = ldify(value);\n\n            if (v.type === \"Language\") {\n              return v.languageTag === ld.language; // @@ use equals/normalizeTest\n            }\n\n            if (!(typeof v === \"object\" && \"value\" in v)) return false;\n            return v.value === ld.value && v.type === ld.type && v.language === ld.language;\n          }, false)) {// literal match\n          } else if (valueExpr.values.indexOf(value) !== -1) {// trivial match\n          } else {\n            if (!valueExpr.values.some(function (valueConstraint) {\n              if (typeof valueConstraint === \"object\" && !(\"value\" in valueConstraint)) {\n                /* expect N3.js literals with {Literal,Language}StemRange\n                 *       or non-literals with IriStemRange\n                 */\n                var normalizedTest = function normalizedTest(val, ref, func) {\n                  if (RdfTerm.isLiteral(val)) {\n                    if ([\"LiteralStem\", \"LiteralStemRange\"].indexOf(valueConstraint.type) !== -1) {\n                      return func(RdfTerm.getLiteralValue(val), ref);\n                    } else if ([\"LanguageStem\", \"LanguageStemRange\"].indexOf(valueConstraint.type) !== -1) {\n                      return func(RdfTerm.getLiteralLanguage(val) || null, ref);\n                    } else {\n                      return validationError(\"literal \" + val + \" not comparable with non-literal \" + ref);\n                    }\n                  } else {\n                    if ([\"IriStem\", \"IriStemRange\"].indexOf(valueConstraint.type) === -1) {\n                      return validationError(\"nonliteral \" + val + \" not comparable with literal \" + JSON.stringify(ref));\n                    } else {\n                      return func(val, ref);\n                    }\n                  }\n                };\n\n                var startsWith = function startsWith(val, ref) {\n                  return normalizedTest(val, ref, function (l, r) {\n                    return valueConstraint.type === \"LanguageStem\" || valueConstraint.type === \"LanguageStemRange\" ? // rfc4647 basic filtering\n                    l !== null && (l === r || r === \"\" || l[r.length] === \"-\") : // simple substring\n                    l.startsWith(r);\n                  });\n                };\n\n                var equals = function equals(val, ref) {\n                  return normalizedTest(val, ref, function (l, r) {\n                    return l === r;\n                  });\n                };\n\n                // isTerm me -- strike \"value\" in\n                if (!(\"type\" in valueConstraint)) runtimeError(\"expected \" + JSON.stringify(valueConstraint) + \" to have a 'type' attribute.\");\n                var stemRangeTypes = [\"Language\", \"IriStem\", \"LiteralStem\", \"LanguageStem\", \"IriStemRange\", \"LiteralStemRange\", \"LanguageStemRange\"];\n                if (stemRangeTypes.indexOf(valueConstraint.type) === -1) runtimeError(\"expected type attribute '\" + valueConstraint.type + \"' to be in '\" + stemRangeTypes + \"'.\");\n\n                if (!isTerm(valueConstraint.stem)) {\n                  expect(valueConstraint.stem, \"type\", \"Wildcard\"); // match whatever but check exclusions below\n                } else {\n                  if (!startsWith(value, valueConstraint.stem)) {\n                    return false;\n                  }\n                }\n\n                if (valueConstraint.exclusions) {\n                  return !valueConstraint.exclusions.some(function (c) {\n                    if (!isTerm(c)) {\n                      if (!(\"type\" in c)) runtimeError(\"expected \" + JSON.stringify(c) + \" to have a 'type' attribute.\");\n                      var stemTypes = [\"IriStem\", \"LiteralStem\", \"LanguageStem\"];\n                      if (stemTypes.indexOf(c.type) === -1) runtimeError(\"expected type attribute '\" + c.type + \"' to be in '\" + stemTypes + \"'.\");\n                      return startsWith(value, c.stem);\n                    } else {\n                      return equals(value, c);\n                    }\n                  });\n                }\n\n                return true;\n              } else {// ignore -- would have caught it above\n              }\n            })) {\n              validationError(\"value \" + value + \" not found in set \" + JSON.stringify(valueExpr.values));\n            }\n          }\n        }\n      }\n\n      if (\"pattern\" in valueExpr) {\n        var regexp = \"flags\" in valueExpr ? new RegExp(valueExpr.pattern, valueExpr.flags) : new RegExp(valueExpr.pattern);\n        if (!getLexicalValue(value).match(regexp)) validationError(\"value \" + getLexicalValue(value) + \" did not match pattern \" + valueExpr.pattern);\n      }\n\n      Object.keys(stringTests).forEach(function (test) {\n        if (test in valueExpr && !stringTests[test](label, valueExpr[test])) {\n          validationError(\"facet violation: expected \" + test + \" of \" + valueExpr[test] + \" but got \" + value);\n        }\n      });\n      Object.keys(numericValueTests).forEach(function (test) {\n        if (test in valueExpr) {\n          if (numeric) {\n            if (!numericValueTests[test](numericParsers[numeric](label, validationError), valueExpr[test])) {\n              validationError(\"facet violation: expected \" + test + \" of \" + valueExpr[test] + \" but got \" + value);\n            }\n          } else {\n            validationError(\"facet violation: numeric facet \" + test + \" can't apply to \" + value);\n          }\n        }\n      });\n      Object.keys(decimalLexicalTests).forEach(function (test) {\n        if (test in valueExpr) {\n          if (numeric === XSD + \"integer\" || numeric === XSD + \"decimal\") {\n            if (!decimalLexicalTests[test](\"\" + numericParsers[numeric](label, validationError), valueExpr[test])) {\n              validationError(\"facet violation: expected \" + test + \" of \" + valueExpr[test] + \" but got \" + value);\n            }\n          } else {\n            validationError(\"facet violation: numeric facet \" + test + \" can't apply to \" + value);\n          }\n        }\n      });\n      var ret = {\n        type: null,\n        focus: value,\n        shapeExpr: valueExpr\n      };\n\n      if (errors.length) {\n        ret.type = \"NodeConstraintViolation\";\n        ret.errors = errors;\n      } else {\n        ret.type = \"NodeConstraintTest\";\n      }\n\n      return ret;\n    };\n\n    this.semActHandler = {\n      handlers: {},\n      results: {},\n\n      /**\n       * Store a semantic action handler.\n       *\n       * @param {string} name - semantic action's URL.\n       * @param {object} handler - handler function.\n       *\n       * The handler object has a dispatch function is invoked with:\n       * @param {string} code - text of the semantic action.\n       * @param {object} ctx - matched triple or results subset.\n       * @param {object} extensionStorage - place where the extension writes into the result structure.\n       * @return {bool} false if the extension failed or did not accept the ctx object.\n       */\n      register: function register(name, handler) {\n        this.handlers[name] = handler;\n      },\n\n      /**\n       * Calls all semantic actions, allowing each to write to resultsArtifact.\n       *\n       * @param {array} semActs - list of semantic actions to invoke.\n       * @return {bool} false if any result was false.\n       */\n      dispatchAll: function dispatchAll(semActs, ctx, resultsArtifact) {\n        var _semActHanlder = this;\n\n        return semActs.reduce(function (ret, semAct) {\n          if (ret.length === 0 && semAct.name in _semActHanlder.handlers) {\n            var code = \"code\" in semAct ? semAct.code : _ShExValidator.options.semActs[semAct.name];\n            var existing = \"extensions\" in resultsArtifact && semAct.name in resultsArtifact.extensions;\n            var extensionStorage = existing ? resultsArtifact.extensions[semAct.name] : {};\n\n            var response = _semActHanlder.handlers[semAct.name].dispatch(code, ctx, extensionStorage);\n\n            debugger;\n\n            if (typeof response === 'boolean') {\n              if (!response) ret.push({\n                type: \"SemActFailure\",\n                errors: [{\n                  type: \"BooleanSemActFailure\",\n                  code: code,\n                  ctx: ctx\n                }]\n              });\n            } else if (typeof response === 'object' && response.constructor === Array) {\n              if (response.length > 0) ret.push({\n                type: \"SemActFailure\",\n                errors: response\n              });\n            } else {\n              throw Error(\"unsupported response from semantic action handler: \" + JSON.stringify(response));\n            }\n\n            if (!existing && Object.keys(extensionStorage).length > 0) {\n              if (!(\"extensions\" in resultsArtifact)) resultsArtifact.extensions = {};\n              resultsArtifact.extensions[semAct.name] = extensionStorage;\n            }\n\n            return ret;\n          }\n\n          return ret;\n        }, []);\n      }\n    };\n\n    function effectiveShapeExpression(shape, tcs, constraintToExtends) {\n      if (\"extends\" in shape) {\n        shape.extends.forEach(function (se, extendsNo) {\n          // build NestedShape.scopedTripleConstraints = indexes of the TCs in se\n          var ins = {},\n              outs = {}; // constraintToExtends[extendsNo] = [];\n\n          mergeEffectiveTripleConstraints(se, ins, outs);\n          [ins, outs].forEach(function (direction) {\n            Object.keys(direction).forEach(function (p) {\n              // constraintToExtends[extendsNo].push(tcs.length);\n              var tc = direction[p];\n              var cNo = tcs.indexOf(tc);\n\n              if (cNo === -1) {\n                cNo = tcs.length;\n                tcs.push(tc);\n                constraintToExtends[cNo] = [];\n              } else {\n                console.log(\"reuse\", tc);\n              }\n\n              constraintToExtends[cNo].push(extendsNo);\n            });\n          });\n        });\n      }\n\n      return;\n      /** mergeEffectiveTripleConstraints - turn a ShapeExpression with\n       * a projection te into TripleExpression with an optional SE'\n       * where shapes contributing to te are NOPs.\n        * @expr - shape expression to walk\n       * @ins - incoming arcs: map from IRI to {min, max, seen}\n       * @outs - outgoing arcs\n       */\n\n      function mergeEffectiveTripleConstraints(expr, ins, outs) {\n        var visitor = ShExUtil.Visitor();\n        var outerMin = 1;\n        var outerMax = 1;\n        var oldVisitOneOf = visitor.visitOneOf;\n\n        visitor.visitShapeRef = function (inclusion) {\n          return visitor.visitShapeDecl(index.shapeExprs[inclusion]);\n        };\n\n        visitor.visitShape = function (shape, label) {\n          if (\"extends\" in shape) {\n            shape.extends.forEach( // extension of an extension\n            function (se) {\n              return mergeEffectiveTripleConstraints(se, ins, outs);\n            });\n          }\n\n          if (\"expression\" in shape) {\n            visitor.visitExpression(shape.expression);\n          }\n\n          return {\n            type: \"Shape\"\n          }; // NOP\n        };\n\n        visitor.visitOneOf = function (expr) {\n          var oldOuterMin = outerMin;\n          var oldOuterMax = outerMax;\n          outerMin = 0;\n          oldVisitOneOf.call(visitor, expr);\n          outerMin = oldOuterMin;\n          outerMax = oldOuterMax;\n        };\n\n        visitor.visitTripleConstraint = function (expr) {\n          idx = expr.inverse ? ins : outs; // pick an index\n\n          var min = \"min\" in expr ? expr.min : 1;\n          min = min * outerMin;\n          var max = \"max\" in expr ? expr.max : 1;\n          max = max * outerMax;\n          idx[expr.predicate] = {\n            type: \"TripleConstraint\",\n            predicate: expr.predicate,\n            min: expr.predicate in idx ? Math.max(idx[expr.predicate].min, min) : min,\n            max: expr.predicate in idx ? Math.min(idx[expr.predicate].max, max) : max,\n            seen: expr.predicate in idx ? idx[expr.predicate].seen + 1 : 1,\n            tcs: expr.predicate in idx ? idx[expr.predicate].tcs.concat([expr]) : [expr]\n          };\n          return expr;\n        };\n\n        visitor.visitShapeExpr(expr);\n      }\n    }\n  }\n  /* _compileShapeToAST - compile a shape expression to an abstract syntax tree.\n   *\n   * currently tested but not used.\n   */\n\n\n  function _compileShapeToAST(expression, tripleConstraints, schema) {\n    function Epsilon() {\n      this.type = \"Epsilon\";\n    }\n\n    function TripleConstraint(ordinal, predicate, inverse, negated, valueExpr) {\n      this.type = \"TripleConstraint\"; // this.ordinal = ordinal; @@ does 1card25\n\n      this.inverse = !!inverse;\n      this.negated = !!negated;\n      this.predicate = predicate;\n      if (valueExpr !== undefined) this.valueExpr = valueExpr;\n    }\n\n    function Choice(disjuncts) {\n      this.type = \"Choice\";\n      this.disjuncts = disjuncts;\n    }\n\n    function EachOf(conjuncts) {\n      this.type = \"EachOf\";\n      this.conjuncts = conjuncts;\n    }\n\n    function SemActs(expression, semActs) {\n      this.type = \"SemActs\";\n      this.expression = expression;\n      this.semActs = semActs;\n    }\n\n    function KleeneStar(expression) {\n      this.type = \"KleeneStar\";\n      this.expression = expression;\n    }\n\n    function _compileExpression(expr, schema) {\n      var repeated, container;\n      /* _repeat: map expr with a min and max cardinality to a corresponding AST with Groups and Stars.\n         expr 1 1 => expr\n         expr 0 1 => Choice(expr, Eps)\n         expr 0 3 => Choice(EachOf(expr, Choice(EachOf(expr, Choice(expr, EPS)), Eps)), Eps)\n         expr 2 5 => EachOf(expr, expr, Choice(EachOf(expr, Choice(EachOf(expr, Choice(expr, EPS)), Eps)), Eps))\n         expr 0 * => KleeneStar(expr)\n         expr 1 * => EachOf(expr, KleeneStar(expr))\n         expr 2 * => EachOf(expr, expr, KleeneStar(expr))\n          @@TODO: favor Plus over Star if Epsilon not in expr.\n      */\n\n      function _repeat(expr, min, max) {\n        if (min === undefined) {\n          min = 1;\n        }\n\n        if (max === undefined) {\n          max = 1;\n        }\n\n        if (min === 1 && max === 1) {\n          return expr;\n        }\n\n        var opts = max === UNBOUNDED ? new KleeneStar(expr) : _seq(max - min).reduce(function (ret, elt, ord) {\n          return ord === 0 ? new Choice([expr, new Epsilon()]) : new Choice([new EachOf([expr, ret]), new Epsilon()]);\n        }, undefined);\n        var reqd = min !== 0 ? new EachOf(_seq(min).map(function (ret) {\n          return expr; // @@ something with ret\n        }).concat(opts)) : opts;\n        return reqd;\n      }\n\n      if (typeof expr === \"string\") {\n        // Inclusion\n        var included = schema._index.tripleExprs[expr].expression;\n        return _compileExpression(included, schema);\n      } else if (expr.type === \"TripleConstraint\") {\n        // predicate, inverse, negated, valueExpr, annotations, semActs, min, max\n        var valueExpr = \"valueExprRef\" in expr ? schema.valueExprDefns[expr.valueExprRef] : expr.valueExpr;\n        var ordinal = tripleConstraints.push(expr) - 1;\n        var tp = new TripleConstraint(ordinal, expr.predicate, expr.inverse, expr.negated, valueExpr);\n        repeated = _repeat(tp, expr.min, expr.max);\n        return expr.semActs ? new SemActs(repeated, expr.semActs) : repeated;\n      } else if (expr.type === \"OneOf\") {\n        container = new Choice(expr.expressions.map(function (e) {\n          return _compileExpression(e, schema);\n        }));\n        repeated = _repeat(container, expr.min, expr.max);\n        return expr.semActs ? new SemActs(repeated, expr.semActs) : repeated;\n      } else if (expr.type === \"EachOf\") {\n        container = new EachOf(expr.expressions.map(function (e) {\n          return _compileExpression(e, schema);\n        }));\n        repeated = _repeat(container, expr.min, expr.max);\n        return expr.semActs ? new SemActs(repeated, expr.semActs) : repeated;\n      } else throw Error(\"unexpected expr type: \" + expr.type);\n    }\n\n    return expression ? _compileExpression(expression, schema) : new Epsilon();\n  } // http://stackoverflow.com/questions/9422386/lazy-cartesian-product-of-arrays-arbitrary-nested-loops\n\n\n  function crossProduct(sets) {\n    var n = sets.length,\n        carets = [],\n        args = null;\n\n    function init() {\n      args = [];\n\n      for (var i = 0; i < n; i++) {\n        carets[i] = 0;\n        args[i] = sets[i][0];\n      }\n    }\n\n    function next() {\n      // special case: crossProduct([]).next().next() returns false.\n      if (args !== null && args.length === 0) return false;\n\n      if (args === null) {\n        init();\n        return true;\n      }\n\n      var i = n - 1;\n      carets[i]++;\n\n      if (carets[i] < sets[i].length) {\n        args[i] = sets[i][carets[i]];\n        return true;\n      }\n\n      while (carets[i] >= sets[i].length) {\n        if (i == 0) {\n          return false;\n        }\n\n        carets[i] = 0;\n        args[i] = sets[i][0];\n        carets[--i]++;\n      }\n\n      args[i] = sets[i][carets[i]];\n      return true;\n    }\n\n    return {\n      next: next,\n      do: function _do(block, _context) {\n        // old API\n        return block.apply(_context, args);\n      },\n      // new API because\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments#Description\n      // cautions about functions over arguments.\n      get: function get() {\n        return args;\n      }\n    };\n  }\n  /* N3jsTripleToString - simple toString function to make N3.js's triples\n   * printable.\n   */\n\n\n  var N3jsTripleToString = function N3jsTripleToString() {\n    function fmt(n) {\n      return RdfTerm.isLiteral(n) ? [\"http://www.w3.org/2001/XMLSchema#integer\", \"http://www.w3.org/2001/XMLSchema#float\", \"http://www.w3.org/2001/XMLSchema#double\"].indexOf(RdfTerm.getLiteralType(n)) !== -1 ? parseInt(RdfTerm.getLiteralValue(n)) : n : RdfTerm.isBlank(n) ? n : \"<\" + n + \">\";\n    }\n\n    return fmt(this.subject) + \" \" + fmt(this.predicate) + \" \" + fmt(this.object) + \" .\";\n  };\n  /* indexNeighborhood - index triples by predicate\n   * returns: {\n   *     byPredicate: Object: mapping from predicate to triples containing that\n   *                  predicate.\n   *\n   *     candidates: [[1,3], [0,2]]: mapping from triple to the triple constraints\n   *                 it matches.  It is initialized to []. Mappings that remain an\n   *                 empty set indicate a triple which didn't matching anything in\n   *                 the shape.\n   *\n   *     misses: list to recieve value constraint failures.\n   *   }\n   */\n\n\n  function indexNeighborhood(triples) {\n    return {\n      byPredicate: triples.reduce(function (ret, t) {\n        var p = t.predicate;\n        if (!(p in ret)) ret[p] = [];\n        ret[p].push(t); // If in VERBOSE mode, add a nice toString to N3.js's triple objects.\n\n        if (VERBOSE) t.toString = N3jsTripleToString;\n        return ret;\n      }, {}),\n      candidates: _seq(triples.length).map(function () {\n        return [];\n      }),\n      misses: []\n    };\n  }\n  /* sparqlOrder - sort triples by subject following SPARQL partial ordering.\n   */\n\n\n  function sparqlOrder(l, r) {\n    var _map = [l, r].map(function (x) {\n      return RdfTerm.isBlank(x) ? 1 : RdfTerm.isLiteral(x) ? 2 : 3;\n    }),\n        _map2 = _slicedToArray(_map, 2),\n        lprec = _map2[0],\n        rprec = _map2[1];\n\n    return lprec === rprec ? l.localeCompare(r) : lprec - rprec;\n  }\n  /* Return a list of n \"\"s.\n   *\n   * Note that Array(n) on its own returns a \"sparse array\" so Array(n).map(f)\n   * never calls f.\n   */\n\n\n  function _seq(n) {\n    return n === 0 ? [] : Array(n).join(\" \").split(/ /); // hahaha, javascript, you suck.\n  }\n  /* Expect property p with value v in object o\n   */\n\n\n  function expect(o, p, v) {\n    if (!(p in o)) runtimeError(\"expected \" + JSON.stringify(o) + \" to have a '\" + p + \"' attribute.\");\n    if (arguments.length > 2 && o[p] !== v) runtimeError(\"expected \" + p + \" attribute '\" + o[p] + \"' to equal '\" + v + \"'.\");\n  }\n\n  function noop() {}\n\n  function runtimeError() {\n    var errorStr = Array.prototype.join.call(arguments, \"\");\n    var e = new Error(errorStr);\n    Error.captureStackTrace(e, runtimeError);\n    throw e;\n  }\n\n  function _alist(len) {\n    return _seq(len).map(function () {\n      return [];\n    });\n  }\n\n  return {\n    construct: ShExValidator_constructor,\n    start: Start,\n    options: InterfaceOptions\n  };\n}(); // Export the `ShExValidator` class as a whole.\n\n\nif (typeof require !== \"undefined\" && typeof exports !== \"undefined\") module.exports = ShExValidator;","map":null,"metadata":{},"sourceType":"script"}