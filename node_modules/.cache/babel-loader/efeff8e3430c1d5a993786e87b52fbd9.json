{"ast":null,"code":"var ThreadedValNErr = function () {\n  var RdfTerm = require(\"../RdfTerm\");\n\n  var UNBOUNDED = -1;\n\n  function vpEngine(schema, shape, index) {\n    var outerExpression = shape.expression;\n    return {\n      match: match\n    };\n\n    function match(graph, node, constraintList, constraintToTripleMapping, tripleToConstraintMapping, neighborhood, semActHandler, trace) {\n      /*\n       * returns: list of passing or failing threads (no heterogeneous lists)\n       */\n      function validateExpr(expr, thread) {\n        if (typeof expr === \"string\") {\n          // Inclusion\n          var included = index.tripleExprs[expr];\n          return validateExpr(included, thread);\n        }\n\n        var constraintNo = constraintList.indexOf(expr);\n        var min = \"min\" in expr ? expr.min : 1;\n        var max = \"max\" in expr ? expr.max === UNBOUNDED ? Infinity : expr.max : 1;\n\n        function validateRept(type, val) {\n          var repeated = 0,\n              errOut = false;\n          var newThreads = [thread];\n          var minmax = {};\n\n          if (\"min\" in expr && expr.min !== 1 || \"max\" in expr && expr.max !== 1) {\n            minmax.min = expr.min;\n            minmax.max = expr.max;\n          }\n\n          if (\"semActs\" in expr) minmax.semActs = expr.semActs;\n          if (\"annotations\" in expr) minmax.annotations = expr.annotations;\n\n          for (; repeated < max && !errOut; ++repeated) {\n            var inner = [];\n\n            for (var t = 0; t < newThreads.length; ++t) {\n              var newt = newThreads[t];\n              var sub = val(newt);\n\n              if (sub.length > 0 && sub[0].errors.length === 0) {\n                // all subs pass or all fail\n                sub.forEach(function (newThread) {\n                  var solutions = \"expression\" in newt ? newt.expression.solutions : [];\n                  if (\"solution\" in newThread) solutions = solutions.concat(newThread.solution);\n                  delete newThread.solution;\n                  newThread.expression = extend({\n                    type: type,\n                    solutions: solutions\n                  }, minmax);\n                });\n              }\n\n              if (sub.length === 0\n              /* min:0 */\n              || sub[0].errors.length > 0) return repeated < min ? sub : newThreads;else inner = inner.concat(sub); // newThreads.expressions.push(sub);\n            }\n\n            newThreads = inner;\n          }\n\n          if (newThreads.length > 0 && newThreads[0].errors.length === 0 && \"semActs\" in expr) {\n            var passes = [];\n            var failures = [];\n            newThreads.forEach(function (newThread) {\n              var semActErrors = semActHandler.dispatchAll(expr.semActs, \"???\", newThread);\n\n              if (semActErrors.length === 0) {\n                passes.push(newThread);\n              } else {\n                [].push.apply(newThread.errors, semActErrors);\n                failures.push(newThread);\n              }\n            });\n            newThreads = passes.length > 0 ? passes : failures;\n          }\n\n          return newThreads;\n        }\n\n        if (expr.type === \"TripleConstraint\") {\n          var negated = \"negated\" in expr && expr.negated || max === 0;\n          if (negated) min = max = Infinity;\n          if (thread.avail[constraintNo] === undefined) thread.avail[constraintNo] = constraintToTripleMapping[constraintNo].map(function (pair) {\n            return pair.tNo;\n          });\n          var minmax = {};\n\n          if (\"min\" in expr && expr.min !== 1 || \"max\" in expr && expr.max !== 1) {\n            minmax.min = expr.min;\n            minmax.max = expr.max;\n          }\n\n          if (\"semActs\" in expr) minmax.semActs = expr.semActs;\n          if (\"annotations\" in expr) minmax.annotations = expr.annotations;\n          var taken = thread.avail[constraintNo].splice(0, min);\n          var passed = negated ? taken.length === 0 : taken.length >= min;\n          var ret = [];\n          var matched = thread.matched;\n\n          if (passed) {\n            var _loop = function _loop() {\n              var passFail = taken.reduce(function (acc, tripleNo) {\n                var t = neighborhood[tripleNo];\n                var tested = {\n                  type: \"TestedTriple\",\n                  subject: t.subject,\n                  predicate: t.predicate,\n                  object: ldify(t.object)\n                };\n                var hit = constraintToTripleMapping[constraintNo].find(function (x) {\n                  return x.tNo === tripleNo;\n                });\n                if (hit.res && Object.keys(hit.res).length > 0) tested.referenced = hit.res;\n                var semActErrors = thread.errors.concat(\"semActs\" in expr ? semActHandler.dispatchAll(expr.semActs, t, tested) : []);\n                if (semActErrors.length > 0) acc.fail.push({\n                  tripleNo: tripleNo,\n                  tested: tested,\n                  semActErrors: semActErrors\n                });else acc.pass.push({\n                  tripleNo: tripleNo,\n                  tested: tested,\n                  semActErrors: semActErrors\n                });\n                return acc;\n              }, {\n                pass: [],\n                fail: []\n              }); // return an empty solution if min card was 0\n\n              if (passFail.fail.length === 0) {\n                // If we didn't take anything, fall back to old errors.\n                // Could do something fancy here with a semAct registration for negative matches.\n                var totalErrors = taken.length === 0 ? thread.errors.slice() : [];\n                var myThread = makeThread(passFail.pass.map(function (p) {\n                  return p.tripleNo;\n                }), totalErrors);\n                ret.push(myThread); // ret.push();\n              } else {\n                passFail.fail.forEach(function (f) {\n                  return ret.push(makeThread([f.tripleNo], f.semActErrors));\n                });\n              }\n\n              function makeThread(tripleNos, errors) {\n                return {\n                  avail: thread.avail.map(function (a) {\n                    // copy parent thread's avail vector\n                    return a.slice();\n                  }),\n                  errors: errors,\n                  matched: matched.concat({\n                    tNos: tripleNos\n                  }),\n                  expression: extend({\n                    type: \"TripleConstraintSolutions\",\n                    predicate: expr.predicate\n                  }, \"valueExpr\" in expr ? {\n                    valueExpr: expr.valueExpr\n                  } : {}, \"productionLabel\" in expr ? {\n                    productionLabel: expr.productionLabel\n                  } : {}, minmax, {\n                    solutions: tripleNos.map(function (tripleNo) {\n                      var t = neighborhood[tripleNo];\n                      var ret = {\n                        type: \"TestedTriple\",\n                        subject: t.subject,\n                        predicate: t.predicate,\n                        object: ldify(t.object)\n                      };\n                      var hit = constraintToTripleMapping[constraintNo].find(function (x) {\n                        return x.tNo === tripleNo;\n                      });\n                      if (hit.res && Object.keys(hit.res).length > 0) ret.referenced = hit.res;\n                      return ret; // return { type: \"halfTestedTriple\", tripleNo: tripleNo, constraintNo: constraintNo };\n                    })\n                  })\n                };\n              }\n            };\n\n            do {\n              _loop();\n            } while (function () {\n              if (thread.avail[constraintNo].length > 0 && taken.length < max) {\n                // build another thread.\n                taken.push(thread.avail[constraintNo].shift());\n                return true;\n              } else {\n                // no more threads\n                return false;\n              }\n            }());\n          } else {\n            var valueExpr = null;\n\n            if (typeof expr.valueExpr === \"string\") {\n              // ShapeRef\n              valueExpr = expr.valueExpr;\n              if (RdfTerm.isBlank(valueExpr)) valueExpr = index.shapeExprs[valueExpr];\n            } else if (expr.valueExpr) {\n              valueExpr = extend({}, expr.valueExpr);\n            }\n\n            ret.push({\n              avail: thread.avail,\n              errors: thread.errors.concat([extend({\n                type: negated ? \"NegatedProperty\" : \"MissingProperty\",\n                property: expr.predicate\n              }, valueExpr ? {\n                valueExpr: valueExpr\n              } : {})]),\n              matched: matched\n            });\n          }\n\n          return ret;\n        } else if (expr.type === \"OneOf\") {\n          return validateRept(\"OneOfSolutions\", function (th) {\n            var accept = null;\n            var matched = [];\n            var failed = [];\n            expr.expressions.forEach(function (nested) {\n              var thcopy = {\n                avail: th.avail.map(function (a) {\n                  return a.slice();\n                }),\n                errors: th.errors,\n                matched: th.matched //.slice() ever needed??\n\n              };\n              var sub = validateExpr(nested, thcopy);\n\n              if (sub[0].errors.length === 0) {\n                // all subs pass or all fail\n                matched = matched.concat(sub);\n                sub.forEach(function (newThread) {\n                  var expressions = \"solution\" in thcopy ? thcopy.solution.expressions : [];\n                  if (\"expression\" in newThread) // undefined for no matches on min card:0\n                    expressions = expressions.concat([newThread.expression]);\n                  delete newThread.expression;\n                  newThread.solution = {\n                    type: \"OneOfSolution\",\n                    expressions: expressions\n                  };\n                });\n              } else failed = failed.concat(sub);\n            });\n            return matched.length > 0 ? matched : failed;\n          });\n        } else if (expr.type === \"EachOf\") {\n          return homogenize(validateRept(\"EachOfSolutions\", function (th) {\n            // Iterate through nested expressions, exprThreads starts as [th].\n            return expr.expressions.reduce(function (exprThreads, nested) {\n              // Iterate through current thread list composing nextThreads.\n              // Consider e.g.\n              // <S1> { <p1> . | <p2> .; <p3> . } / { <x> <p2> 2; <p3> 3 } (should pass)\n              // <S1> { <p1> .; <p2> . }          / { <s1> <p1> 1 }        (should fail)\n              return homogenize(exprThreads.reduce(function (nextThreads, exprThread) {\n                var sub = validateExpr(nested, exprThread); // Move newThread.expression into a hierarchical solution structure.\n\n                sub.forEach(function (newThread) {\n                  if (newThread.errors.length === 0) {\n                    var expressions = \"solution\" in exprThread ? exprThread.solution.expressions : [];\n                    if (\"expression\" in newThread) // undefined for no matches on min card:0\n                      expressions = expressions.concat([newThread.expression]); // console.warn(threadMatched(newThread), \" vs \", exprMatched(expressions));\n\n                    delete newThread.expression;\n                    newThread.solution = {\n                      type: \"EachOfSolution\",\n                      expressions: expressions // exprThread.expression + newThread.expression\n\n                    };\n                  }\n                });\n                return nextThreads.concat(sub);\n              }, []));\n            }, [th]);\n          }));\n        } // else if (expr.type === \"Inclusion\") {\n        //   var included = schema.productions[expr.include];\n        //   return validateExpr(included, thread);\n        // }\n        // else if (expr.type === \"NestedShape\") {\n        //   var newThreads = [thread]\n        //   return newThreads;\n        // }\n\n\n        runtimeError(\"unexpected expr type: \" + expr.type);\n\n        function homogenize(list) {\n          return list.reduce(function (acc, elt) {\n            if (elt.errors.length === 0) {\n              if (acc.errors) {\n                return {\n                  errors: false,\n                  l: [elt]\n                };\n              } else {\n                return {\n                  errors: false,\n                  l: acc.l.concat(elt)\n                };\n              }\n            } else {\n              if (acc.errors) {\n                return {\n                  errors: true,\n                  l: acc.l.concat(elt)\n                };\n              } else {\n                return acc;\n              }\n            }\n          }, {\n            errors: true,\n            l: []\n          }).l;\n        }\n      }\n\n      var startingThread = {\n        avail: [],\n        // triples remaining by constraint number\n        matched: [],\n        // triples matched in this thread\n        errors: [] // errors encounted\n\n      };\n      if (!outerExpression) return {}; // vapid match if no expression\n\n      var ret = validateExpr(outerExpression, startingThread); // console.log(JSON.stringify(ret));\n      // note: don't return if ret.length === 1 because it might fail the unmatchedTriples test.\n\n      var longerChosen = ret.reduce(function (ret, elt) {\n        if (elt.errors.length > 0) return ret; // early return\n\n        var unmatchedTriples = {}; // Collect triples assigned to some constraint.\n\n        Object.keys(tripleToConstraintMapping).forEach(function (k) {\n          if (tripleToConstraintMapping[k] !== undefined) unmatchedTriples[k] = tripleToConstraintMapping[k];\n        }); // Removed triples matched in this thread.\n\n        elt.matched.forEach(function (m) {\n          m.tNos.forEach(function (t) {\n            delete unmatchedTriples[t];\n          });\n        }); // Remaining triples are unaccounted for.\n\n        Object.keys(unmatchedTriples).forEach(function (t) {\n          elt.errors.push({\n            type: \"ExcessTripleViolation\",\n            triple: neighborhood[t],\n            constraint: constraintList[unmatchedTriples[t]]\n          });\n        });\n        return ret !== null ? ret : // keep first solution\n        // Accept thread with no unmatched triples.\n        Object.keys(unmatchedTriples).length > 0 ? null : elt;\n      }, null);\n      return longerChosen !== null ? finish(longerChosen.expression, constraintList, neighborhood, semActHandler) : ret.length > 1 ? {\n        type: \"PossibleErrors\",\n        errors: ret.reduce(function (all, e) {\n          return all.concat([e.errors]);\n        }, [])\n      } : ret[0];\n    }\n\n    function ldify(term) {\n      if (term[0] !== \"\\\"\") return term;\n      var ret = {\n        value: RdfTerm.getLiteralValue(term)\n      };\n      var dt = RdfTerm.getLiteralType(term);\n      if (dt && dt !== \"http://www.w3.org/2001/XMLSchema#string\" && dt !== \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\") ret.type = dt;\n      var lang = RdfTerm.getLiteralLanguage(term);\n      if (lang) ret.language = lang;\n      return ret;\n    }\n\n    function finish(fromValidatePoint, constraintList, neighborhood, semActHandler) {\n      function _dive(solns) {\n        if (solns.type === \"OneOfSolutions\" || solns.type === \"EachOfSolutions\") {\n          solns.solutions.forEach(function (s) {\n            s.expressions.forEach(function (e) {\n              _dive(e);\n            });\n          });\n        } else if (solns.type === \"TripleConstraintSolutions\") {\n          solns.solutions = solns.solutions.map(function (x) {\n            if (x.type === \"TestedTriple\") // already done\n              return x; // c.f. validation/3circularRef1_pass-open\n\n            var t = neighborhood[x.tripleNo];\n            var expr = constraintList[x.constraintNo];\n            var ret = {\n              type: \"TestedTriple\",\n              subject: t.subject,\n              predicate: t.predicate,\n              object: ldify(t.object)\n            };\n\n            function diver(focus, shapeLabel, dive) {\n              var sub = dive(focus, shapeLabel);\n\n              if (\"errors\" in sub) {\n                // console.dir(sub);\n                var err = {\n                  type: \"ReferenceError\",\n                  focus: focus,\n                  shape: shapeLabel\n                };\n                if (typeof shapeLabel === \"string\" && RdfTerm.isBlank(shapeLabel)) err.referencedShape = shape;\n                err.errors = sub;\n                return [err];\n              }\n\n              if ((\"solution\" in sub || \"solutions\" in sub) && Object.keys(sub.solution || sub.solutions).length !== 0 || sub.type === \"Recursion\") ret.referenced = sub; // !!! needs to aggregate errors and solutions\n\n              return [];\n            }\n\n            function diveRecurse(focus, shapeLabel) {\n              return diver(focus, shapeLabel, recurse);\n            }\n\n            function diveDirect(focus, shapeLabel) {\n              return diver(focus, shapeLabel, direct);\n            }\n\n            var subErrors = \"valueExpr\" in expr ? checkValueExpr(expr.inverse ? t.subject : t.object, expr.valueExpr, diveRecurse, diveDirect) : [];\n            if (subErrors.length === 0 && \"semActs\" in expr) [].push.apply(subErrors, semActHandler.dispatchAll(expr.semActs, t, ret));\n\n            if (subErrors.length > 0) {\n              fromValidatePoint.errors = fromValidatePoint.errors || [];\n              fromValidatePoint.errors = fromValidatePoint.errors.concat(subErrors);\n            }\n\n            return ret;\n          });\n        } else {\n          throw Error(\"unexpected expr type in \" + JSON.stringify(solns));\n        }\n      }\n\n      if (Object.keys(fromValidatePoint).length > 0) // guard against {}\n        _dive(fromValidatePoint);\n      if (\"semActs\" in shape) fromValidatePoint.semActs = shape.semActs;\n      return fromValidatePoint;\n    }\n  }\n\n  function ldify(term) {\n    if (term[0] !== \"\\\"\") return term;\n    var ret = {\n      value: N3Util.getLiteralValue(term)\n    };\n    var dt = N3Util.getLiteralType(term);\n    if (dt && dt !== \"http://www.w3.org/2001/XMLSchema#string\" && dt !== \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\") ret.type = dt;\n    var lang = N3Util.getLiteralLanguage(term);\n    if (lang) ret.language = lang;\n    return ret;\n  }\n\n  function extend(base) {\n    if (!base) base = {};\n\n    for (var i = 1, l = arguments.length, arg; i < l && (arg = arguments[i] || {}); i++) {\n      for (var name in arg) {\n        base[name] = arg[name];\n      }\n    }\n\n    return base;\n  }\n\n  return {\n    name: \"threaded-val-nerr\",\n    description: \"emulation of regular expression engine with error permutations\",\n    compile: vpEngine\n  };\n}();\n\nif (typeof require !== \"undefined\" && typeof exports !== \"undefined\") module.exports = ThreadedValNErr;","map":null,"metadata":{},"sourceType":"script"}