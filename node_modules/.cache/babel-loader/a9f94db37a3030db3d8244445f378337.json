{"ast":null,"code":"import _regeneratorRuntime from \"D:\\\\Downloads\\\\Test HTML\\\\react-medical-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"D:\\\\Downloads\\\\Test HTML\\\\react-medical-app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport data from '@solid/query-ldflex';\nimport { AccessControlList } from '@inrupt/solid-react-components';\nimport { resourceExists, createDoc, createDocument } from \"./ldflex-helper\";\nimport { storageHelper, errorToaster, permissionHelper } from \"./\";\nvar appPath = process.env.REACT_APP_TICTAC_PATH;\n/**\n * Creates a valid string that represents the application path. This is the\n * default value if no storage predicate is discovered\n * @param webId\n * @param path\n * @returns {*}\n */\n\nexport var buildPathFromWebId = function buildPathFromWebId(webId, path) {\n  if (!webId) return false;\n  var domain = new URL(typeof webId === 'object' ? webId.webId : webId).origin;\n  return \"\".concat(domain, \"/\").concat(path);\n};\n/**\n * Helper function to check for the user's pod storage value. If it doesn't exist, we assume root of the pod\n * @returns {Promise<string>}\n */\n\nexport var getAppStorage = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(webId) {\n    var podStoragePath, podStoragePathValue;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return data[webId].storage;\n\n          case 2:\n            podStoragePath = _context.sent;\n            podStoragePathValue = podStoragePath && podStoragePath.value.trim().length > 0 ? podStoragePath.value : ''; // Make sure that the path ends in a / so it is recognized as a folder path\n\n            if (podStoragePathValue && !podStoragePathValue.endsWith('/')) {\n              podStoragePathValue = \"\".concat(podStoragePathValue, \"/\");\n            } // If there is no storage value from the pod, use webId as the backup, and append the application path from env\n\n\n            if (!(!podStoragePathValue || podStoragePathValue.trim().length === 0)) {\n              _context.next = 7;\n              break;\n            }\n\n            return _context.abrupt(\"return\", buildPathFromWebId(webId, appPath));\n\n          case 7:\n            return _context.abrupt(\"return\", \"\".concat(podStoragePathValue).concat(appPath));\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function getAppStorage(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n *  Check and create the initial app files and folders\n * @param folderPath\n * @returns {Promise<boolean>} Returns whether or not there were any errors during the creation process\n */\n\nexport var createInitialFiles = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(webId) {\n    var hasWritePermission, gameUrl, dataFilePath, settingsFilePath, gameFolderExists, dataFileExists, settingsFileExists;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return permissionHelper.checkSpecificAppPermission(webId, AccessControlList.MODES.WRITE);\n\n          case 3:\n            hasWritePermission = _context2.sent;\n\n            if (hasWritePermission) {\n              _context2.next = 6;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 6:\n            _context2.next = 8;\n            return storageHelper.getAppStorage(webId);\n\n          case 8:\n            gameUrl = _context2.sent;\n            // Set up various paths relative to the game URL\n            dataFilePath = \"\".concat(gameUrl, \"data.ttl\");\n            settingsFilePath = \"\".concat(gameUrl, \"settings.ttl\"); // Check if the tictactoe folder exists, if not then create it. This is where game files, the game inbox, and settings files are created by default\n\n            _context2.next = 13;\n            return resourceExists(gameUrl);\n\n          case 13:\n            gameFolderExists = _context2.sent;\n\n            if (gameFolderExists) {\n              _context2.next = 17;\n              break;\n            }\n\n            _context2.next = 17;\n            return createDoc(data, {\n              method: 'PUT',\n              headers: {\n                'Content-Type': 'text/turtle'\n              }\n            });\n\n          case 17:\n            _context2.next = 19;\n            return resourceExists(dataFilePath);\n\n          case 19:\n            dataFileExists = _context2.sent;\n\n            if (dataFileExists) {\n              _context2.next = 23;\n              break;\n            }\n\n            _context2.next = 23;\n            return createDocument(dataFilePath);\n\n          case 23:\n            _context2.next = 25;\n            return resourceExists(settingsFilePath);\n\n          case 25:\n            settingsFileExists = _context2.sent;\n\n            if (settingsFileExists) {\n              _context2.next = 29;\n              break;\n            }\n\n            _context2.next = 29;\n            return createDocument(settingsFilePath);\n\n          case 29:\n            return _context2.abrupt(\"return\", true);\n\n          case 32:\n            _context2.prev = 32;\n            _context2.t0 = _context2[\"catch\"](0);\n            errorToaster(_context2.t0.message, 'Error');\n            return _context2.abrupt(\"return\", false);\n\n          case 36:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 32]]);\n  }));\n\n  return function createInitialFiles(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexport var checkAndInitializeInbox = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", '');\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function checkAndInitializeInbox() {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["D:/Downloads/Test HTML/react-medical-app/src/utils/storage.js"],"names":["data","AccessControlList","resourceExists","createDoc","createDocument","storageHelper","errorToaster","permissionHelper","appPath","process","env","REACT_APP_TICTAC_PATH","buildPathFromWebId","webId","path","domain","URL","origin","getAppStorage","storage","podStoragePath","podStoragePathValue","value","trim","length","endsWith","createInitialFiles","checkSpecificAppPermission","MODES","WRITE","hasWritePermission","gameUrl","dataFilePath","settingsFilePath","gameFolderExists","method","headers","dataFileExists","settingsFileExists","message","checkAndInitializeInbox"],"mappings":"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","sourcesContent":["import data from '@solid/query-ldflex';\nimport { AccessControlList } from '@inrupt/solid-react-components';\nimport { resourceExists, createDoc, createDocument } from './ldflex-helper';\nimport { storageHelper, errorToaster, permissionHelper } from '@utils';\n\nconst appPath = process.env.REACT_APP_TICTAC_PATH;\n\n/**\n * Creates a valid string that represents the application path. This is the\n * default value if no storage predicate is discovered\n * @param webId\n * @param path\n * @returns {*}\n */\nexport const buildPathFromWebId = (webId, path) => {\n  if (!webId) return false;\n  const domain = new URL(typeof webId === 'object' ? webId.webId : webId).origin;\n  return `${domain}/${path}`;\n};\n\n/**\n * Helper function to check for the user's pod storage value. If it doesn't exist, we assume root of the pod\n * @returns {Promise<string>}\n */\nexport const getAppStorage = async webId => {\n  const podStoragePath = await data[webId].storage;\n  let podStoragePathValue =\n    podStoragePath && podStoragePath.value.trim().length > 0 ? podStoragePath.value : '';\n\n  // Make sure that the path ends in a / so it is recognized as a folder path\n  if (podStoragePathValue && !podStoragePathValue.endsWith('/')) {\n    podStoragePathValue = `${podStoragePathValue}/`;\n  }\n\n  // If there is no storage value from the pod, use webId as the backup, and append the application path from env\n  if (!podStoragePathValue || podStoragePathValue.trim().length === 0) {\n    return buildPathFromWebId(webId, appPath);\n  }\n\n  return `${podStoragePathValue}${appPath}`;\n};\n\n/**\n *  Check and create the initial app files and folders\n * @param folderPath\n * @returns {Promise<boolean>} Returns whether or not there were any errors during the creation process\n */\nexport const createInitialFiles = async webId => {\n  try {\n    // First, check if we have WRITE permission for the app\n    const hasWritePermission = await permissionHelper.checkSpecificAppPermission(\n      webId,\n      AccessControlList.MODES.WRITE\n    );\n\n    // If we do not have Write permission, there's nothing we can do here\n    if (!hasWritePermission) return;\n\n    // Get the default app storage location from the user's pod and append our path to it\n    const gameUrl = await storageHelper.getAppStorage(webId);\n\n    // Set up various paths relative to the game URL\n    const dataFilePath = `${gameUrl}data.ttl`;\n    const settingsFilePath = `${gameUrl}settings.ttl`;\n\n    // Check if the tictactoe folder exists, if not then create it. This is where game files, the game inbox, and settings files are created by default\n    const gameFolderExists = await resourceExists(gameUrl);\n    if (!gameFolderExists) {\n      await createDoc(data, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'text/turtle'\n        }\n      });\n    }\n\n    // Check if data file exists, if not then create it. This file holds links to other people's games\n    const dataFileExists = await resourceExists(dataFilePath);\n    if (!dataFileExists) {\n      await createDocument(dataFilePath);\n    }\n\n    // Check if the settings file exists, if not then create it. This file is for general settings including the link to the game-specific inbox\n    const settingsFileExists = await resourceExists(settingsFilePath);\n    if (!settingsFileExists) {\n      await createDocument(settingsFilePath);\n    }\n\n    return true;\n  } catch (error) {\n    errorToaster(error.message, 'Error');\n    return false;\n  }\n};\n\nexport const checkAndInitializeInbox = async () => '';\n"]},"metadata":{},"sourceType":"module"}