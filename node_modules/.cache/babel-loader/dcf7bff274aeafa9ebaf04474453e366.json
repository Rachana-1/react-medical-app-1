{"ast":null,"code":"// **ShExWriter** writes ShEx documents.\nvar ShExWriter = function () {\n  var util = require('util');\n\n  var UNBOUNDED = -1; // Matches a literal as represented in memory by the ShEx library\n\n  var ShExLiteralMatcher = /^\"([^]*)\"(?:\\^\\^(.+)|@([\\-a-z]+))?$/i; // rdf:type predicate (for 'a' abbreviation)\n\n  var RDF_PREFIX = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n      RDF_TYPE = RDF_PREFIX + 'type'; // Characters in literals that require escaping\n\n  var ESCAPE_1 = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n      ESCAPE_g = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n      ESCAPE_replacements = {\n    '\\\\': '\\\\\\\\',\n    '\"': '\\\\\"',\n    '/': '\\\\/',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\b': '\\\\b',\n    '\\f': '\\\\f'\n  };\n  var nodeKinds = {\n    'iri': \"IRI\",\n    'bnode': \"BNODE\",\n    'literal': \"LITERAL\",\n    'nonliteral': \"NONLITERAL\"\n  };\n  var nonLitNodeKinds = {\n    'iri': \"IRI\",\n    'bnode': \"BNODE\",\n    'literal': \"LITERAL\",\n    'nonliteral': \"NONLITERAL\"\n  }; // ## Constructor\n\n  function ShExWriter(outputStream, options) {\n    if (!(this instanceof ShExWriter)) return new ShExWriter(outputStream, options); // Shift arguments if the first argument is not a stream\n\n    if (outputStream && typeof outputStream.write !== 'function') options = outputStream, outputStream = null;\n    options = options || {}; // If no output stream given, send the output as string through the end callback\n\n    if (!outputStream) {\n      var output = '';\n      this._outputStream = {\n        write: function write(chunk, encoding, done) {\n          output += chunk;\n          done && done();\n        },\n        end: function end(done) {\n          done && done(null, output);\n        }\n      };\n      this._endStream = true;\n    } else {\n      this._outputStream = outputStream;\n      this._endStream = options.end === undefined ? true : !!options.end;\n    } // Initialize writer, depending on the format\n\n\n    this._prefixIRIs = Object.create(null);\n    options.prefixes && this.addPrefixes(options.prefixes);\n    this._error = options.error || _throwError;\n    this.forceParens = !options.simplifyParentheses; // default to false\n\n    this._expect = options.lax ? noop : expect;\n  }\n\n  ShExWriter.prototype = {\n    // ## Private methods\n    // ### `_write` writes the argument to the output stream\n    _write: function _write(string, callback) {\n      this._outputStream.write(string, 'utf8', callback);\n    },\n    // ### `_writeSchema` writes the shape to the output stream\n    _writeSchema: function _writeSchema(schema, done) {\n      var _ShExWriter = this;\n\n      this._expect(schema, \"type\", \"Schema\");\n\n      _ShExWriter.addPrefixes(schema.prefixes);\n\n      if (schema.base) _ShExWriter._write(\"BASE \" + this._encodeIriOrBlankNode(schema.base) + \"\\n\");\n      if (schema.imports) schema.imports.forEach(function (imp) {\n        _ShExWriter._write(\"IMPORT \" + _ShExWriter._encodeIriOrBlankNode(imp) + \"\\n\");\n      });\n      if (schema.startActs) schema.startActs.forEach(function (act) {\n        _ShExWriter._expect(act, \"type\", \"SemAct\");\n\n        _ShExWriter._write(\" %\" + _ShExWriter._encodePredicate(act.name) + (\"code\" in act ? \"{\" + escapeCode(act.code) + \"%\" + \"}\" : \"%\"));\n      });\n      if (schema.start) _ShExWriter._write(\"start = \" + _ShExWriter._writeShapeExpr(schema.start, done, true, 0).join('') + \"\\n\");\n      if (\"shapes\" in schema) schema.shapes.forEach(function (shapeExpr) {\n        var id = shapeExpr.id;\n        var abstract = \"\";\n\n        if (shapeExpr.type === \"ShapeDecl\") {\n          if (shapeExpr.abstract) abstract = \"abstract \";\n          shapeExpr = shapeExpr.shapeExpr;\n        }\n\n        _ShExWriter._write(abstract + _ShExWriter._encodeShapeName(id, false) + \" \" + _ShExWriter._writeShapeExpr(shapeExpr, done, true, 0).join(\"\") + \"\\n\", done);\n      });\n    },\n    _writeShapeExpr: function _writeShapeExpr(shapeExpr, done, forceBraces, parentPrec) {\n      var _ShExWriter = this;\n\n      var pieces = [];\n      if (typeof shapeExpr === \"string\") // ShapeRef\n        pieces.push(\"@\", _ShExWriter._encodeShapeName(shapeExpr)); // !!! []s for precedence!\n      else if (shapeExpr.type === \"ShapeDecl\") pieces.push(_ShExWriter._writeShapeExpr(shapeExpr.shapeExpr, done, false, 3));else if (shapeExpr.type === \"ShapeExternal\") pieces.push(\"EXTERNAL\");else if (shapeExpr.type === \"ShapeAnd\") {\n          if (parentPrec >= 3) pieces.push(\"(\");\n          var lastAndElided = false;\n          shapeExpr.shapeExprs.forEach(function (expr, ord) {\n            if (ord > 0) {\n              // && !!! grammar rules too weird here\n\n              /*\n                shapeAtom:\n                      nonLitNodeConstraint shapeOrRef?\n                    | shapeDecl nonLitNodeConstraint?\n                 nonLitInlineNodeConstraint:\n                      nonLiteralKind stringFacet*\n              */\n              var nonLitNodeConstraint = function nonLitNodeConstraint(idx) {\n                var c = shapeExpr.shapeExprs[idx];\n                return c.type !== \"NodeConstraint\" || \"nodeKind\" in c && c.nodeKind === \"literal\" || \"datatype\" in c || \"values\" in c ? false : true;\n              };\n\n              var shapeOrRef = function shapeOrRef(idx) {\n                var c = shapeExpr.shapeExprs[idx];\n                return c.type === \"Shape\" || c.type === \"ShapeRef\";\n              };\n\n              var shapeDecl = function shapeDecl(idx) {\n                var c = shapeExpr.shapeExprs[idx];\n                return c.type === \"Shape\";\n              };\n\n              var elideAnd = !lastAndElided && (nonLitNodeConstraint(ord - 1) && shapeOrRef(ord) || shapeDecl(ord - 1) && nonLitNodeConstraint(ord));\n\n              if (!elideAnd) {\n                pieces.push(\" AND \");\n              }\n\n              lastAndElided = elideAnd;\n            }\n\n            pieces = pieces.concat(_ShExWriter._writeShapeExpr(expr, done, false, 3));\n          });\n          if (parentPrec >= 3) pieces.push(\")\");\n        } else if (shapeExpr.type === \"ShapeOr\") {\n          if (parentPrec >= 2) pieces.push(\"(\");\n          shapeExpr.shapeExprs.forEach(function (expr, ord) {\n            if (ord > 0) pieces.push(\" OR \");\n            pieces = pieces.concat(_ShExWriter._writeShapeExpr(expr, done, forceBraces, 2));\n          });\n          if (parentPrec >= 2) pieces.push(\")\");\n        } else if (shapeExpr.type === \"ShapeNot\") {\n          if (parentPrec >= 4) pieces.push(\"(\");\n          pieces.push(\"NOT \");\n          pieces = pieces.concat(_ShExWriter._writeShapeExpr(shapeExpr.shapeExpr, done, forceBraces, 4));\n          if (parentPrec >= 4) pieces.push(\")\");\n        } else if (shapeExpr.type === \"Shape\") {\n          pieces = pieces.concat(_ShExWriter._writeShape(shapeExpr, done, forceBraces));\n        } else if (shapeExpr.type === \"NodeConstraint\") {\n          pieces = pieces.concat(_ShExWriter._writeNodeConstraint(shapeExpr, done, forceBraces));\n        } else throw Error(\"expected Shape{,And,Or,Ref} or NodeConstraint in \" + util.inspect(shapeExpr));\n      return pieces;\n    },\n    // ### `_writeShape` writes the shape to the output stream\n    _writeShape: function _writeShape(shape, done, forceBraces) {\n      var _ShExWriter = this;\n\n      try {\n        var _writeShapeActions = function _writeShapeActions(semActs) {\n          if (!semActs) return;\n          semActs.forEach(function (act) {\n            _ShExWriter._expect(act, \"type\", \"SemAct\");\n\n            pieces.push(\" %\", _ShExWriter._encodePredicate(act.name), \"code\" in act ? \"{\" + escapeCode(act.code) + \"%\" + \"}\" : \"%\");\n          });\n        };\n\n        var _writeCardinality = function _writeCardinality(min, max) {\n          if (min === 0 && max === 1) pieces.push(\"?\");else if (min === 0 && max === UNBOUNDED) pieces.push(\"*\");else if (min === undefined && max === undefined) ;else if (min === 1 && max === UNBOUNDED) pieces.push(\"+\");else pieces.push(\"{\", min, \",\", max === UNBOUNDED ? \"*\" : max, \"}\"); // by coincidence, both use the same character.\n        };\n\n        var _writeExpression = function _writeExpression(expr, indent, parentPrecedence) {\n          function _writeScopedShapeExpression(scopedShapeExpr) {\n            if (scopedShapeExpr) {\n              pieces.push(\" ON SHAPE EXPRESSION\\n\");\n              pieces = pieces.concat(_ShExWriter._writeShapeExpr(scopedShapeExpr, done, true, 0).map(function (line) {\n                return indent + \"    \" + line;\n              }));\n            }\n          }\n\n          function _writeExpressionActions(semActs) {\n            if (semActs) {\n              semActs.forEach(function (act) {\n                _ShExWriter._expect(act, \"type\", \"SemAct\");\n\n                pieces.push(\"\\n\" + indent + \"   %\");\n                pieces.push(_ShExWriter._encodeValue(act.name));\n                if (\"code\" in act) pieces.push(\"{\" + escapeCode(act.code) + \"%\" + \"}\");else pieces.push(\"%\");\n              });\n            }\n          }\n\n          function _exprGroup(exprs, separator, precedence, forceParens) {\n            var needsParens = precedence < parentPrecedence || forceParens;\n\n            if (needsParens) {\n              pieces.push(\"(\");\n            }\n\n            exprs.forEach(function (nested, ord) {\n              _writeExpression(nested, indent + \"  \", precedence);\n\n              if (ord < exprs.length - 1) pieces.push(separator);\n            });\n\n            if (needsParens) {\n              pieces.push(\")\");\n            }\n          }\n\n          if (typeof expr === \"string\") {\n            pieces.push(\"&\");\n            pieces.push(_ShExWriter._encodeShapeName(expr, false));\n          } else {\n            if (\"id\" in expr) {\n              pieces.push(\"$\");\n              pieces.push(_ShExWriter._encodeIriOrBlankNode(expr.id, true));\n            }\n\n            if (expr.type === \"TripleConstraint\") {\n              if (expr.inverse) pieces.push(\"^\");\n              if (expr.negated) pieces.push(\"!\");\n              pieces.push(indent, _ShExWriter._encodePredicate(expr.predicate), \" \");\n              if (\"valueExpr\" in expr) pieces = pieces.concat(_ShExWriter._writeShapeExpr(expr.valueExpr, done, true, 0));else pieces.push(\". \");\n\n              _writeCardinality(expr.min, expr.max);\n\n              _writeScopedShapeExpression(expr.onShapeExpression);\n\n              _ShExWriter._annotations(pieces, expr.annotations, indent);\n\n              _writeExpressionActions(expr.semActs);\n            } else if (expr.type === \"OneOf\") {\n              var needsParens = \"id\" in expr || \"min\" in expr || \"max\" in expr || \"onShapeExpression\" in expr || \"annotations\" in expr || \"semActs\" in expr;\n\n              _exprGroup(expr.expressions, \"\\n\" + indent + \"| \", 1, needsParens || _ShExWriter.forceParens);\n\n              _writeCardinality(expr.min, expr.max); // t: open1dotclosecardOpt\n\n\n              _writeScopedShapeExpression(expr.onShapeExpression);\n\n              _ShExWriter._annotations(pieces, expr.annotations, indent);\n\n              _writeExpressionActions(expr.semActs);\n            } else if (expr.type === \"EachOf\") {\n              var needsParens = \"id\" in expr || \"min\" in expr || \"max\" in expr || \"onShapeExpression\" in expr || \"annotations\" in expr || \"semActs\" in expr;\n\n              _exprGroup(expr.expressions, \";\\n\" + indent, 2, needsParens || _ShExWriter.forceParens);\n\n              _writeCardinality(expr.min, expr.max); // t: open1dotclosecardOpt\n\n\n              _writeScopedShapeExpression(expr.onShapeExpression);\n\n              _ShExWriter._annotations(pieces, expr.annotations, indent);\n\n              _writeExpressionActions(expr.semActs);\n            } else throw Error(\"unexpected expr type: \" + expr.type);\n          }\n        };\n\n        var pieces = []; // guessing push/join is faster than concat\n\n        this._expect(shape, \"type\", \"Shape\");\n\n        if (shape.closed) pieces.push(\"CLOSED \");\n        [{\n          keyword: \"extends\",\n          marker: \"&\"\n        }].forEach(function (pair) {\n          // pieces = pieces.concat(_ShExWriter._writeShapeExpr(expr.valueExpr, done, true, 0));\n          if (shape[pair.keyword] && shape[pair.keyword].length > 0) {\n            shape[pair.keyword].forEach(function (i, ord) {\n              if (ord) pieces.push(\" \");\n              pieces.push(pair.marker);\n              pieces = pieces.concat(_ShExWriter._writeShapeExpr(i, done, true, 0));\n            });\n            pieces.push(\" \");\n          }\n        });\n\n        if (shape.extra && shape.extra.length > 0) {\n          pieces.push(\"EXTRA \");\n          shape.extra.forEach(function (i, ord) {\n            pieces.push(_ShExWriter._encodeShapeName(i, false) + \" \");\n          });\n          pieces.push(\" \");\n        }\n\n        var empties = [\"values\", \"length\", \"minlength\", \"maxlength\", \"pattern\", \"flags\"];\n        pieces.push(\"{\\n\");\n        if (shape.expression) // t: 0, 0Extend1\n          _writeExpression(shape.expression, \"  \", 0);\n        pieces.push(\"\\n}\");\n\n        _writeShapeActions(shape.semActs);\n\n        _ShExWriter._annotations(pieces, shape.annotations, \"  \");\n\n        return pieces;\n      } catch (error) {\n        done && done(error);\n      }\n    },\n    // ### `_writeShape` writes the shape to the output stream\n    _writeNodeConstraint: function _writeNodeConstraint(v, done) {\n      var _ShExWriter = this;\n\n      try {\n        _ShExWriter._expect(v, \"type\", \"NodeConstraint\");\n\n        var pieces = [];\n        if (v.nodeKind in nodeKinds) pieces.push(nodeKinds[v.nodeKind], \" \");else if (v.nodeKind !== undefined) _ShExWriter._error(\"unexpected nodeKind: \" + v.nodeKind); // !!!!\n\n        this._fillNodeConstraint(pieces, v, done);\n\n        this._annotations(pieces, v.annotations, \"  \");\n\n        return pieces;\n      } catch (error) {\n        done && done(error);\n      }\n    },\n    _annotations: function _annotations(pieces, annotations, indent) {\n      var _ShExWriter = this;\n\n      if (annotations) {\n        annotations.forEach(function (a) {\n          _ShExWriter._expect(a, \"type\", \"Annotation\");\n\n          pieces.push(\"//\\n\" + indent + \"   \");\n          pieces.push(_ShExWriter._encodeValue(a.predicate));\n          pieces.push(\" \");\n          pieces.push(_ShExWriter._encodeValue(a.object));\n        });\n      }\n    },\n    _fillNodeConstraint: function _fillNodeConstraint(pieces, v, done) {\n      var _ShExWriter = this;\n\n      if (v.datatype && v.values) _ShExWriter._error(\"found both datatype and values in \" + expr);\n\n      if (v.datatype) {\n        pieces.push(_ShExWriter._encodeShapeName(v.datatype));\n      }\n\n      if (v.values) {\n        pieces.push(\"[\");\n        v.values.forEach(function (t, ord) {\n          if (ord > 0) pieces.push(\" \");\n\n          if (!isTerm(t)) {\n            var langOrLiteral = function langOrLiteral(t, c) {\n              return [\"LanguageStem\", \"LanguageStemRange\"].indexOf(t.type) !== -1 ? \"@\" + c : [\"LiteralStem\", \"LiteralStemRange\"].indexOf(t.type) !== -1 ? '\"' + c.replace(ESCAPE_g, c) + '\"' : _ShExWriter._encodeValue(c);\n            };\n\n            //          expect(t, \"type\", \"IriStemRange\");\n            if (!(\"type\" in t)) runtimeError(\"expected \" + JSON.stringify(t) + \" to have a 'type' attribute.\");\n            var stemRangeTypes = [\"Language\", \"IriStem\", \"LiteralStem\", \"LanguageStem\", \"IriStemRange\", \"LiteralStemRange\", \"LanguageStemRange\"];\n            if (stemRangeTypes.indexOf(t.type) === -1) runtimeError(\"expected type attribute '\" + t.type + \"' to be in '\" + stemRangeTypes + \"'.\");\n\n            if (t.type === \"Language\") {\n              pieces.push(\"@\" + t.languageTag);\n            } else if (!isTerm(t.stem)) {\n              expect(t.stem, \"type\", \"Wildcard\");\n              pieces.push(\".\");\n            } else {\n              pieces.push(langOrLiteral(t, t.stem) + \"~\");\n            }\n\n            if (t.exclusions) {\n              t.exclusions.forEach(function (c) {\n                pieces.push(\" - \");\n\n                if (!isTerm(c)) {\n                  //                expect(c, \"type\", \"IriStem\");\n                  if (!(\"type\" in c)) runtimeError(\"expected \" + JSON.stringify(c) + \" to have a 'type' attribute.\");\n                  var stemTypes = [\"IriStem\", \"LiteralStem\", \"LanguageStem\"];\n                  if (stemTypes.indexOf(c.type) === -1) runtimeError(\"expected type attribute '\" + c.type + \"' to be in '\" + stemTypes + \"'.\");\n                  pieces.push(langOrLiteral(t, c.stem) + \"~\");\n                } else {\n                  pieces.push(langOrLiteral(t, c));\n                }\n              });\n            }\n          } else {\n            pieces.push(_ShExWriter._encodeValue(t));\n          }\n        });\n        pieces.push(\"]\");\n      }\n\n      if ('pattern' in v) {\n        var pattern = v.pattern.replace(/\\//g, \"\\\\/\"); // if (ESCAPE_1.test(pattern))\n        //   pattern = pattern.replace(ESCAPE_g, characterReplacer);\n\n        var flags = 'flags' in v ? v.flags : \"\";\n        pieces.push(\"/\" + pattern + \"/\" + flags + \" \");\n      }\n\n      ['length', 'minlength', 'maxlength', 'mininclusive', 'minexclusive', 'maxinclusive', 'maxexclusive', 'totaldigits', 'fractiondigits'].forEach(function (a) {\n        if (v[a]) pieces.push(\" \", a, \" \", v[a]);\n      });\n      return pieces;\n\n      function isTerm(t) {\n        return typeof t !== \"object\" || \"value\" in t && Object.keys(t).reduce(function (r, k) {\n          return r === false ? r : [\"value\", \"type\", \"language\"].indexOf(k) !== -1;\n        }, true);\n      }\n    },\n    // ### `_encodeIriOrBlankNode` represents an IRI or blank node\n    _encodeIriOrBlankNode: function _encodeIriOrBlankNode(iri, trailingSpace) {\n      trailingSpace = trailingSpace ? ' ' : ''; // A blank node is represented as-is\n\n      if (iri[0] === '_' && iri[1] === ':') return iri; // Escape special characters\n\n      if (ESCAPE_1.test(iri)) iri = iri.replace(ESCAPE_g, characterReplacer); // Try to represent the IRI as prefixed name\n\n      var prefixMatch = this._prefixRegex.exec(iri);\n\n      return !prefixMatch ? '<' + iri + '>' : (!prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2]) + trailingSpace;\n    },\n    // ### `_encodeLiteral` represents a literal\n    _encodeLiteral: function _encodeLiteral(value, type, language) {\n      // Escape special characters\n      if (ESCAPE_1.test(value)) value = value.replace(ESCAPE_g, characterReplacer); // Write the literal, possibly with type or language\n\n      if (language) return '\"' + value + '\"@' + language;else if (type) return '\"' + value + '\"^^' + this._encodeIriOrBlankNode(type);else return '\"' + value + '\"';\n    },\n    // ### `_encodeShapeName` represents a subject\n    _encodeShapeName: function _encodeShapeName(subject, trailingSpace) {\n      if (subject[0] === '\"') throw new Error('A literal as subject is not allowed: ' + subject);\n      return this._encodeIriOrBlankNode(subject, trailingSpace);\n    },\n    // ### `_encodePredicate` represents a predicate\n    _encodePredicate: function _encodePredicate(predicate) {\n      if (predicate[0] === '\"') throw new Error('A literal as predicate is not allowed: ' + predicate);\n      return predicate === RDF_TYPE ? 'a' : this._encodeIriOrBlankNode(predicate);\n    },\n    // ### `_encodeValue` represents an object\n    _encodeValue: function _encodeValue(object) {\n      // Represent an IRI or blank node\n      if (typeof object !== \"object\") return this._encodeIriOrBlankNode(object); // Represent a literal\n\n      return this._encodeLiteral(object.value, object.type, object.language);\n    },\n    // ### `_blockedWrite` replaces `_write` after the writer has been closed\n    _blockedWrite: function _blockedWrite() {\n      throw new Error('Cannot write because the writer has been closed.');\n    },\n    writeSchema: function writeSchema(shape, done) {\n      this._writeSchema(shape, done);\n\n      this.end(done);\n    },\n    // ### `addShape` adds the shape to the output stream\n    addShape: function addShape(shape, name, done) {\n      this._write(_ShExWriter._encodeShapeName(name, false) + \" \" + _ShExWriter._writeShapeExpr(shape, done, true, 0).join(\"\"), done);\n    },\n    // ### `addShapes` adds the shapes to the output stream\n    addShapes: function addShapes(shapes) {\n      for (var i = 0; i < shapes.length; i++) {\n        this.addShape(shapes[i]);\n      }\n    },\n    // ### `addPrefix` adds the prefix to the output stream\n    addPrefix: function addPrefix(prefix, iri, done) {\n      var prefixes = {};\n      prefixes[prefix] = iri;\n      this.addPrefixes(prefixes, done);\n    },\n    // ### `addPrefixes` adds the prefixes to the output stream\n    addPrefixes: function addPrefixes(prefixes, done) {\n      // Add all useful prefixes\n      var prefixIRIs = this._prefixIRIs,\n          hasPrefixes = false;\n\n      for (var prefix in prefixes) {\n        // Verify whether the prefix can be used and does not exist yet\n        var iri = prefixes[prefix];\n\n        if ( // @@ /[#\\/]$/.test(iri) && !! what was that?\n        prefixIRIs[iri] !== (prefix += ':')) {\n          hasPrefixes = true;\n          prefixIRIs[iri] = prefix; // Write prefix\n\n          this._write('PREFIX ' + prefix + ' <' + iri + '>\\n');\n        }\n      } // Recreate the prefix matcher\n\n\n      if (hasPrefixes) {\n        var IRIlist = '',\n            prefixList = '';\n\n        for (var prefixIRI in prefixIRIs) {\n          IRIlist += IRIlist ? '|' + prefixIRI : prefixIRI;\n          prefixList += (prefixList ? '|' : '') + prefixIRIs[prefixIRI];\n        }\n\n        IRIlist = IRIlist.replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n        this._prefixRegex = new RegExp('^(?:' + prefixList + ')[^\\/]*$|' + '^(' + IRIlist + ')([a-zA-Z][\\\\-_a-zA-Z0-9]*)$');\n      } // End a prefix block with a newline\n\n\n      this._write(hasPrefixes ? '\\n' : '', done);\n    },\n    // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes\n    _prefixRegex: /$0^/,\n    // ### `end` signals the end of the output stream\n    end: function end(done) {\n      // Disallow further writing\n      this._write = this._blockedWrite; // Try to end the underlying stream, ensuring done is called exactly one time\n\n      var singleDone = done && function (error, result) {\n        singleDone = null, done(error, result);\n      };\n\n      if (this._endStream) {\n        try {\n          return this._outputStream.end(singleDone);\n        } catch (error) {\n          /* error closing stream */\n        }\n      }\n\n      singleDone && singleDone();\n    }\n  }; // Replaces a character by its escaped version\n\n  function characterReplacer(character) {\n    // Replace a single character by its escaped version\n    var result = ESCAPE_replacements[character];\n\n    if (result === undefined) {\n      // Replace a single character with its 4-bit unicode escape sequence\n      if (character.length === 1) {\n        result = character.charCodeAt(0).toString(16);\n        result = \"\\\\u0000\".substr(0, 6 - result.length) + result;\n      } // Replace a surrogate pair with its 8-bit unicode escape sequence\n      else {\n          result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);\n          result = \"\\\\U00000000\".substr(0, 10 - result.length) + result;\n        }\n    }\n\n    return result;\n  }\n\n  function escapeCode(code) {\n    return code.replace(/\\\\/g, \"\\\\\\\\\").replace(/%/g, \"\\\\%\");\n  }\n  /** _throwError: overridable function to throw Errors().\n   *\n   * @param func (optional): function at which to truncate stack trace\n   * @param str: error message\n   */\n\n\n  function _throwError(func, str) {\n    if (typeof func !== \"function\") {\n      str = func;\n      func = _throwError;\n    }\n\n    var e = new Error(str);\n    Error.captureStackTrace(e, func);\n    throw e;\n  } // Expect property p with value v in object o\n\n\n  function expect(o, p, v) {\n    if (!(p in o)) this._error(expect, \"expected \" + o + \" to have a .\" + p);\n    if (arguments.length > 2 && o[p] !== v) this._error(expect, \"expected \" + o[o] + \" to equal .\" + v);\n  } // The empty function\n\n\n  function noop() {}\n\n  return ShExWriter;\n}(); // Export the `ShExWriter` class as a whole.\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') module.exports = ShExWriter; // node environment","map":null,"metadata":{},"sourceType":"script"}