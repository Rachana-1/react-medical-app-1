{"ast":null,"code":"var ShExParser = function () {\n  // stolen as much as possible from SPARQL.js\n  if (typeof require !== 'undefined' && typeof exports !== 'undefined') {\n    ShExJison = require('./lib/ShExJison').Parser; // node environment\n  } else {\n    ShExJison = ShExJison.Parser; // browser environment\n  } // Creates a ShEx parser with the given pre-defined prefixes\n\n\n  var prepareParser = function prepareParser(baseIRI, prefixes, schemaOptions) {\n    schemaOptions = schemaOptions || {}; // Create a copy of the prefixes\n\n    var prefixesCopy = {};\n\n    for (var prefix in prefixes || {}) {\n      prefixesCopy[prefix] = prefixes[prefix];\n    } // Create a new parser with the given prefixes\n    // (Workaround for https://github.com/zaach/jison/issues/241)\n\n\n    var parser = new ShExJison();\n\n    function runParser() {\n      // ShExJison.base = baseIRI || \"\";\n      // ShExJison.basePath = ShExJison.base.replace(/[^\\/]*$/, '');\n      // ShExJison.baseRoot = ShExJison.base.match(/^(?:[a-z]+:\\/*)?[^\\/]*/)[0];\n      ShExJison._prefixes = Object.create(prefixesCopy);\n      ShExJison._imports = [];\n\n      ShExJison._setBase(baseIRI);\n\n      ShExJison._setFileName(baseIRI);\n\n      ShExJison.options = schemaOptions;\n      var errors = [];\n\n      ShExJison.recoverable = function (e) {\n        return errors.push(e);\n      };\n\n      var ret = null;\n\n      try {\n        ret = ShExJison.prototype.parse.apply(parser, arguments);\n      } catch (e) {\n        errors.push(e);\n      }\n\n      ShExJison.reset();\n      errors.forEach(function (e) {\n        if (\"hash\" in e) {\n          var hash = e.hash;\n          var location = hash.loc;\n          delete hash.loc;\n          Object.assign(e, hash, {\n            location: location\n          });\n        }\n\n        return e;\n      });\n\n      if (errors.length == 1) {\n        errors[0].parsed = ret;\n        throw errors[0];\n      } else if (errors.length) {\n        var all = new Error(\"\" + errors.length + \" parser errors:\\n\" + errors.map(function (e) {\n          return contextError(e, parser.yy.lexer);\n        }).join(\"\\n\"));\n        all.errors = errors;\n        all.parsed = ret;\n        throw all;\n      } else {\n        return ret;\n      }\n    }\n\n    parser.parse = runParser;\n\n    parser._setBase = function (base) {\n      ShExJison._setBase;\n      baseIRI = base;\n    };\n\n    parser._setFileName = ShExJison._setFileName;\n\n    parser._setOptions = function (opts) {\n      ShExJison.options = opts;\n    };\n\n    parser._resetBlanks = ShExJison._resetBlanks;\n    parser.reset = ShExJison.reset;\n    ShExJison.options = schemaOptions;\n    return parser;\n\n    function contextError(e, lexer) {\n      // use the lexer's pretty-printing\n      var line = e.location.first_line;\n      var col = e.location.first_column + 1;\n      var posStr = \"pos\" in e.hash ? \"\\n\" + e.hash.pos : \"\";\n      return \"\".concat(baseIRI, \"\\n line: \").concat(line, \", column: \").concat(col, \": \").concat(e.message).concat(posStr);\n    }\n  };\n\n  return {\n    construct: prepareParser\n  };\n}();\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') module.exports = ShExParser;","map":null,"metadata":{},"sourceType":"script"}