{"ast":null,"code":"var NFAXVal1Err = function () {\n  var RdfTerm = require(\"../RdfTerm\");\n\n  var Split = \"<span class='keyword' title='Split'>|</span>\";\n  var Rept = \"<span class='keyword' title='Repeat'>×</span>\";\n  var Match = \"<span class='keyword' title='Match'>␃</span>\";\n  /* compileNFA - compile regular expression and index triple constraints\n   */\n\n  var UNBOUNDED = -1;\n\n  function compileNFA(schema, shape, index) {\n    var expression = shape.expression;\n    return NFA();\n\n    function NFA() {\n      // wrapper for states, startNo and matchstate\n      var states = [];\n      var matchstate = State_make(Match, []);\n      var startNo = matchstate;\n      var stack = [];\n      var pair;\n\n      if (expression) {\n        var pair = walkExpr(expression, []);\n        patch(pair.tail, matchstate);\n        startNo = pair.start;\n      }\n\n      var ret = {\n        algorithm: \"rbenx\",\n        end: matchstate,\n        states: states,\n        start: startNo,\n        match: rbenx_match\n      };\n      matchstate = states = startNo = null;\n      return ret;\n\n      function walkExpr(expr, stack) {\n        var s, starts;\n        var lastTail;\n\n        function maybeAddRept(start, tail) {\n          if ((expr.min == undefined || expr.min === 1) && (expr.max == undefined || expr.max === 1)) return {\n            start: start,\n            tail: tail\n          };\n          s = State_make(Rept, [start]);\n          states[s].expr = expr; // cache min/max in normalized form for simplicity of comparison.\n\n          states[s].min = \"min\" in expr ? expr.min : 1;\n          states[s].max = \"max\" in expr ? expr.max === UNBOUNDED ? Infinity : expr.max : 1;\n          patch(tail, s);\n          return {\n            start: s,\n            tail: [s]\n          };\n        }\n\n        if (typeof expr === \"string\") {\n          // Inclusion\n          var included = index.tripleExprs[expr];\n          return walkExpr(included, stack);\n        } else if (expr.type === \"TripleConstraint\") {\n          s = State_make(expr, []);\n          states[s].stack = stack;\n          return {\n            start: s,\n            tail: [s]\n          }; // maybeAddRept(s, [s]);\n        } else if (expr.type === \"NestedShape\") {\n          s = State_make(expr, []);\n          states[s].stack = stack;\n          return {\n            start: s,\n            tail: [s]\n          }; // maybeAddRept(s, [s]);\n        } else if (expr.type === \"OneOf\") {\n          lastTail = [];\n          starts = [];\n          expr.expressions.forEach(function (nested, ord) {\n            pair = walkExpr(nested, stack.concat({\n              c: expr,\n              e: ord\n            }));\n            starts.push(pair.start);\n            lastTail = lastTail.concat(pair.tail);\n          });\n          s = State_make(Split, starts);\n          states[s].expr = expr;\n          return maybeAddRept(s, lastTail);\n        } else if (expr.type === \"EachOf\") {\n          expr.expressions.forEach(function (nested, ord) {\n            pair = walkExpr(nested, stack.concat({\n              c: expr,\n              e: ord\n            }));\n            if (ord === 0) s = pair.start;else patch(lastTail, pair.start);\n            lastTail = pair.tail;\n          });\n          return maybeAddRept(s, lastTail);\n        }\n\n        throw Error(\"unexpected expr type: \" + expr.type);\n      }\n\n      ;\n\n      function State_make(c, outs, negated) {\n        var ret = states.length;\n        states.push({\n          c: c,\n          outs: outs\n        });\n        if (negated) states[ret].negated = true; // only include if true for brevity\n\n        return ret;\n      }\n\n      function patch(l, target) {\n        l.forEach(function (elt) {\n          states[elt].outs.push(target);\n        });\n      }\n    }\n\n    function nfaToString() {\n      var known = {\n        OneOf: [],\n        EachOf: []\n      };\n\n      function dumpTripleConstraint(tc) {\n        return \"<\" + tc.predicate + \">\";\n      }\n\n      function card(obj) {\n        var x = \"\";\n        if (\"min\" in obj) x += obj.min;\n        if (\"max\" in obj) x += \",\" + obj.max;\n        return x ? \"{\" + x + \"}\" : \"\";\n      }\n\n      function junct(j) {\n        var id = known[j.type].indexOf(j);\n        if (id === -1) id = known[j.type].push(j) - 1;\n        return j.type + id; // + card(j);\n      }\n\n      function dumpStackElt(elt) {\n        return junct(elt.c) + \".\" + elt.e + (\"i\" in elt ? \"[\" + elt.i + \"]\" : \"\");\n      }\n\n      function dumpStack(stack) {\n        return stack.map(function (elt) {\n          return dumpStackElt(elt);\n        }).join(\"/\");\n      }\n\n      function dumpNFA(states, startNo) {\n        return states.map(function (s, i) {\n          return (i === startNo ? s.c === Match ? \".\" : \"S\" : s.c === Match ? \"E\" : \" \") + i + \" \" + (s.c === Split ? \"Split-\" + junct(s.expr) : s.c === Rept ? \"Rept-\" + junct(s.expr) : s.c === Match ? \"Match\" : dumpTripleConstraint(s.c)) + card(s) + \"→\" + s.outs.join(\" | \") + (\"stack\" in s ? dumpStack(s.stack) : \"\");\n        }).join(\"\\n\");\n      }\n\n      function dumpMatched(matched) {\n        return matched.map(function (m) {\n          return dumpTripleConstraint(m.c) + \"[\" + m.triples.join(\",\") + \"]\" + dumpStack(m.stack);\n        }).join(\",\");\n      }\n\n      function dumpThread(thread) {\n        return \"S\" + thread.state + \":\" + Object.keys(thread.repeats).map(function (k) {\n          return k + \"×\" + thread.repeats[k];\n        }).join(\",\") + \" \" + dumpMatched(thread.matched);\n      }\n\n      function dumpThreadList(list) {\n        return \"[[\" + list.map(function (thread) {\n          return dumpThread(thread);\n        }).join(\"\\n  \") + \"]]\";\n      }\n\n      return {\n        nfa: dumpNFA,\n        stack: dumpStack,\n        stackElt: dumpStackElt,\n        thread: dumpThread,\n        threadList: dumpThreadList\n      };\n    }\n\n    function rbenx_match(graph, node, constraintList, constraintToTripleMapping, tripleToConstraintMapping, neighborhood, semActHandler, trace) {\n      var rbenx = this;\n      var clist = [],\n          nlist = []; // list of {state:state number, repeats:stateNo->repetitionCount}\n\n      function localExpect(list) {\n        return list.map(function (st) {\n          var s = rbenx.states[st.state]; // simpler threads are a list of states.\n\n          return renderAtom(s.c, s.negated);\n        });\n      }\n\n      if (rbenx.states.length === 1) return matchedToResult([], constraintList, constraintToTripleMapping, neighborhood, semActHandler);\n      var chosen = null; // var dump = nfaToString();\n      // console.log(dump.nfa(this.states, this.start));\n\n      addstate(rbenx, clist, this.start, {\n        repeats: {},\n        avail: [],\n        matched: [],\n        stack: [],\n        errors: []\n      });\n\n      while (clist.length) {\n        nlist = [];\n        if (trace) trace.push({\n          threads: []\n        });\n\n        for (var threadno = 0; threadno < clist.length; ++threadno) {\n          var thread = clist[threadno];\n          if (thread.state === rbenx.end) continue;\n          var state = rbenx.states[thread.state];\n          var nlistlen = nlist.length;\n          var constraintNo = constraintList.indexOf(state.c); // may be Accept!\n\n          if (constraintNo === -1) {\n            var scoped = state.c.scopedTripleConstraints.reduce(function (acc, tci) {\n              return acc.concat(constraintToTripleMapping[tci]);\n            }, []);\n            addStates(rbenx, nlist, thread, scoped, constraintToTripleMapping, neighborhood, null, node);\n          } else {\n            var min = \"min\" in state.c ? state.c.min : 1;\n            var max = \"max\" in state.c ? state.c.max === UNBOUNDED ? Infinity : state.c.max : 1;\n            if (\"negated\" in state.c && state.c.negated) min = max = 0;\n            if (thread.avail[constraintNo] === undefined) thread.avail[constraintNo] = constraintToTripleMapping[constraintNo].map(function (pair) {\n              return pair.tNo;\n            });\n            var taken = thread.avail[constraintNo].splice(0, max);\n\n            if (taken.length >= min) {\n              do {\n                addStates(rbenx, nlist, thread, taken, constraintToTripleMapping, neighborhood, null, node);\n              } while (function () {\n                if (thread.avail[constraintNo].length > 0 && taken.length < max) {\n                  taken.push(thread.avail[constraintNo].shift());\n                  return true; // stay in look to take more.\n                } else {\n                  return false; // no more to take or we're already at max\n                }\n              }());\n            }\n          }\n\n          if (trace) trace[trace.length - 1].threads.push({\n            state: clist[threadno].state,\n            to: nlist.slice(nlistlen).map(function (x) {\n              return stateString(x.state, x.repeats);\n            })\n          });\n        } // console.log(dump.threadList(nlist));\n\n\n        if (nlist.length === 0 && chosen === null) return reportError(localExpect(clist, rbenx.states));\n        var t = clist;\n        clist = nlist;\n        nlist = t;\n        var longerChosen = clist.reduce(function (ret, elt) {\n          var matchedAll = elt.matched.reduce(function (ret, m) {\n            return ret + m.triples.length; // count matched triples\n          }, 0) === tripleToConstraintMapping.reduce(function (ret, t) {\n            return t === undefined ? ret : ret + 1; // count expected\n          }, 0);\n          return ret !== null ? ret : elt.state === rbenx.end && matchedAll ? elt : null;\n        }, null);\n        if (longerChosen) chosen = longerChosen; // if (longerChosen !== null)\n        //   console.log(JSON.stringify(matchedToResult(longerChosen.matched)));\n      }\n\n      if (chosen === null) return reportError();\n\n      function reportError() {\n        return {\n          type: \"Failure\",\n          node: node,\n          errors: localExpect(clist, rbenx.states)\n        };\n      }\n\n      function localExpect() {\n        return clist.map(function (t) {\n          var c = rbenx.states[t.state].c; // if (c === Match)\n          //   return { type: \"EndState999\" };\n\n          var valueExpr = null;\n\n          if (typeof c.valueExpr === \"string\") {\n            // ShapeRef\n            valueExpr = c.valueExpr;\n            if (RdfTerm.isBlank(valueExpr)) valueExpr = schema.shapes[valueExpr];\n          } else if (c.valueExpr) {\n            valueExpr = extend({}, c.valueExpr);\n          }\n\n          return extend({\n            type: state.c.negated ? \"NegatedProperty\" : t.state === rbenx.end ? \"ExcessTripleViolation\" : \"MissingProperty\",\n            property: state.c.predicate\n          }, valueExpr ? {\n            valueExpr: valueExpr\n          } : {});\n        });\n      } // console.log(\"chosen:\", dump.thread(chosen));\n\n\n      return \"errors\" in chosen.matched ? chosen.matched : matchedToResult(chosen.matched, constraintList, constraintToTripleMapping, neighborhood, semActHandler);\n    }\n\n    function addStates(rbenx, nlist, thread, taken, constraintToTripleMapping, neighborhood, direct, node) {\n      var state = rbenx.states[thread.state]; // find the exprs that require repetition\n\n      var exprs = rbenx.states.map(function (x) {\n        return x.c === Rept ? x.expr : null;\n      });\n      var newStack = state.stack.map(function (e) {\n        var i = thread.repeats[exprs.indexOf(e.c)];\n        if (i === undefined) i = 0; // expr has no repeats\n        else i = i - 1;\n        return {\n          c: e.c,\n          e: e.e,\n          i: i\n        };\n      });\n      var withIndexes = {\n        c: state.c,\n        triples: taken,\n        stack: newStack\n      };\n      thread.matched = thread.matched.concat(withIndexes);\n      state.outs.forEach(function (o) {\n        // single out if NFA includes epsilons\n        addstate(rbenx, nlist, o, thread);\n      });\n    }\n\n    function addstate(rbenx, list, stateNo, thread, seen) {\n      seen = seen || [];\n      var seenkey = stateString(stateNo, thread.repeats);\n      if (seen.indexOf(seenkey) !== -1) return;\n      seen.push(seenkey);\n      var s = rbenx.states[stateNo];\n\n      if (s.c === Split) {\n        return s.outs.reduce(function (ret, o, idx) {\n          return ret.concat(addstate(rbenx, list, o, thread, seen));\n        }, []); // } else if (s.c.type === \"OneOf\" || s.c.type === \"EachOf\") { // don't need Rept\n      } else if (s.c === Rept) {\n        var ret = []; // matched = [matched].concat(\"Rept\" + s.expr);\n\n        if (!(stateNo in thread.repeats)) thread.repeats[stateNo] = 0;\n        var repetitions = thread.repeats[stateNo]; // add(r < s.min ? outs[0] : r >= s.min && < s.max ? outs[0], outs[1] : outs[1])\n\n        if (repetitions < s.max) ret = ret.concat(addstate(rbenx, list, s.outs[0], incrmRepeat(thread, stateNo), seen)); // outs[0] to repeat\n\n        if (repetitions >= s.min && repetitions <= s.max) ret = ret.concat(addstate(rbenx, list, s.outs[1], resetRepeat(thread, stateNo), seen)); // outs[1] when done\n\n        return ret;\n      } else {\n        // if (stateNo !== rbenx.end || !thread.avail.reduce((r2, avail) => { faster if we trim early??\n        //   return r2 || avail.length > 0;\n        // }, false))\n        return [list.push({\n          // return [new list element index]\n          state: stateNo,\n          repeats: thread.repeats,\n          avail: thread.avail.map(function (a) {\n            // copy parent thread's avail vector\n            return a.slice();\n          }),\n          stack: thread.stack,\n          matched: thread.matched,\n          errors: thread.errors\n        }) - 1];\n      }\n    }\n\n    function resetRepeat(thread, repeatedState) {\n      var trimmedRepeats = Object.keys(thread.repeats).reduce(function (r, k) {\n        if (parseInt(k) !== repeatedState) // ugh, hash keys are strings\n          r[k] = thread.repeats[k];\n        return r;\n      }, {});\n      return {\n        state: thread.state\n        /*???*/\n        ,\n        repeats: trimmedRepeats,\n        matched: thread.matched,\n        avail: thread.avail.slice(),\n        stack: thread.stack\n      };\n    }\n\n    function incrmRepeat(thread, repeatedState) {\n      var incrmedRepeats = Object.keys(thread.repeats).reduce(function (r, k) {\n        r[k] = parseInt(k) == repeatedState ? thread.repeats[k] + 1 : thread.repeats[k];\n        return r;\n      }, {});\n      return {\n        state: thread.state\n        /*???*/\n        ,\n        repeats: incrmedRepeats,\n        matched: thread.matched,\n        avail: thread.avail.slice(),\n        stack: thread.stack\n      };\n    }\n\n    function stateString(state, repeats) {\n      var rs = Object.keys(repeats).map(function (rpt) {\n        return rpt + \":\" + repeats[rpt];\n      }).join(\",\");\n      return rs.length ? state + \"-\" + rs : \"\" + state;\n    }\n\n    function matchedToResult(matched, constraintList, constraintToTripleMapping, neighborhood, semActHandler) {\n      var last = [];\n      var errors = [];\n      var skips = [];\n      var ret = matched.reduce(function (out, m) {\n        var mis = 0;\n        var ptr = out,\n            t;\n\n        while (mis < last.length && m.stack[mis].c === last[mis].c && // constraint\n        m.stack[mis].i === last[mis].i && // iteration number\n        m.stack[mis].e === last[mis].e) {\n          // (dis|con)junction number\n          ptr = ptr.solutions[last[mis].i].expressions[last[mis].e];\n          ++mis;\n        }\n\n        while (mis < m.stack.length) {\n          if (mis >= last.length) {\n            last.push({});\n          }\n\n          if (m.stack[mis].c !== last[mis].c) {\n            t = [];\n            ptr.type = m.stack[mis].c.type === \"EachOf\" ? \"EachOfSolutions\" : \"OneOfSolutions\", ptr.solutions = t;\n            if (\"min\" in m.stack[mis].c) ptr.min = m.stack[mis].c.min;\n            if (\"max\" in m.stack[mis].c) ptr.max = m.stack[mis].c.max;\n            if (\"annotations\" in m.stack[mis].c) ptr.annotations = m.stack[mis].c.annotations;\n            if (\"semActs\" in m.stack[mis].c) ptr.semActs = m.stack[mis].c.semActs;\n            ptr = t;\n            last[mis].i = null; // !!! on the way out to call after valueExpr test\n\n            if (\"semActs\" in m.stack[mis].c) {\n              var _errors = semActHandler.dispatchAll(m.stack[mis].c.semActs, \"???\", ptr);\n\n              if (_errors.length) throw _errors;\n            }\n\n            if (ret && \"semActs\" in expr) {\n              ret.semActs = expr.semActs;\n            }\n          } else {\n            ptr = ptr.solutions;\n          }\n\n          if (m.stack[mis].i !== last[mis].i) {\n            t = [];\n            ptr[m.stack[mis].i] = {\n              type: m.stack[mis].c.type === \"EachOf\" ? \"EachOfSolution\" : \"OneOfSolution\",\n              expressions: t\n            };\n            ptr = t;\n            last[mis].e = null;\n          } else {\n            ptr = ptr[last[mis].i].expressions;\n          }\n\n          if (m.stack[mis].e !== last[mis].e) {\n            t = {};\n            ptr[m.stack[mis].e] = t;\n            if (m.stack[mis].e > 0 && ptr[m.stack[mis].e - 1] === undefined && skips.indexOf(ptr) === -1) skips.push(ptr);\n            ptr = t;\n            last.length = mis + 1; // chop off last so we create everything underneath\n          } else {\n            throw \"how'd we get here?\";\n            ptr = ptr[last[mis].e];\n          }\n\n          ++mis;\n        }\n\n        ptr.type = \"TripleConstraintSolutions\";\n        if (\"min\" in m.c) ptr.min = m.c.min;\n        if (\"max\" in m.c) ptr.max = m.c.max;\n        ptr.predicate = m.c.predicate;\n        if (\"valueExpr\" in m.c) ptr.valueExpr = m.c.valueExpr;\n        if (\"productionLabel\" in m.c) ptr.productionLabel = m.c.productionLabel;\n        ptr.solutions = m.triples.map(function (tNo) {\n          var triple = neighborhood[tNo];\n          var ret = {\n            type: \"TestedTriple\",\n            subject: triple.subject,\n            predicate: triple.predicate,\n            object: ldify(triple.object)\n          };\n\n          function ldify(term) {\n            if (term[0] !== \"\\\"\") return term;\n            var ret = {\n              value: RdfTerm.getLiteralValue(term)\n            };\n            var dt = RdfTerm.getLiteralType(term);\n            if (dt && dt !== \"http://www.w3.org/2001/XMLSchema#string\" && dt !== \"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString\") ret.type = dt;\n            var lang = RdfTerm.getLiteralLanguage(term);\n            if (lang) ret.language = lang;\n            return ret;\n          }\n\n          var constraintNo = constraintList.indexOf(m.c);\n          var hit = constraintToTripleMapping[constraintNo].find(function (x) {\n            return x.tNo === tNo;\n          });\n          if (hit.res && Object.keys(hit.res).length > 0) ret.referenced = hit.res;\n          if (errors.length === 0 && \"semActs\" in m.c) [].push.apply(errors, semActHandler.dispatchAll(m.c.semActs, triple, ret));\n          return ret;\n        });\n        if (\"annotations\" in m.c) ptr.annotations = m.c.annotations;\n        if (\"semActs\" in m.c) ptr.semActs = m.c.semActs;\n        last = m.stack.slice();\n        return out;\n      }, {});\n      if (errors.length) return {\n        type: \"SemActFailure\",\n        errors: errors\n      }; // Clear out the nulls for the expressions with min:0 and no matches.\n      // <S> { (:p .; :q .)?; :r . } \\ { <s> :r 1 } -> i:0, e:1 resulting in null at e=0\n      // Maybe we want these nulls in expressions[] to make it clear that there are holes?\n\n      skips.forEach(function (skip) {\n        for (var exprNo = 0; exprNo < skip.length; ++exprNo) {\n          if (skip[exprNo] === null || skip[exprNo] === undefined) skip.splice(exprNo--, 1);\n        }\n      });\n      if (\"semActs\" in shape) ret.semActs = shape.semActs;\n      return ret;\n    }\n  }\n\n  function extend(base) {\n    if (!base) base = {};\n\n    for (var i = 1, l = arguments.length, arg; i < l && (arg = arguments[i] || {}); i++) {\n      for (var name in arg) {\n        base[name] = arg[name];\n      }\n    }\n\n    return base;\n  } // ## Exports\n\n\n  return exports = {\n    name: \"nfax-val-1err\",\n    description: \"simple regular expression engine with n out states\",\n    compile: compileNFA\n  };\n}();\n\nif (typeof require !== \"undefined\" && typeof exports !== \"undefined\") module.exports = NFAXVal1Err;","map":null,"metadata":{},"sourceType":"script"}