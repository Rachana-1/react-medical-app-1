import { IActionHttp, IActorHttpOutput } from '@comunica/bus-http';
import { BindingsStream } from '@comunica/bus-query-operation';
import { ActionContext, Actor, IActorTest, Mediator } from '@comunica/core';
import * as RDF from 'rdf-js';
import { Factory } from 'sparqlalgebrajs';
export declare class RdfSourceSparql implements RDF.Source {
    protected static readonly FACTORY: Factory;
    private readonly url;
    private readonly context;
    private readonly mediatorHttp;
    constructor(url: string, context: ActionContext | undefined, mediatorHttp: Mediator<Actor<IActionHttp, IActorTest, IActorHttpOutput>, IActionHttp, IActorTest, IActorHttpOutput>);
    /**
     * Return a new variable if the term is undefined, or the term as-is.
     * @param {Term | undefined} term A term or undefined.
     * @param {string} variableName A variable name to assign when the term was null.
     * @return {Term} A term.
     */
    static materializeOptionalTerm(term: RDF.Term | undefined, variableName: string): RDF.Term;
    /**
     * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.
     * @param {string} endpoint A SPARQL endpoint URL.
     * @param {string} query A SPARQL query string.
     * @param {ActionContext} context An optional context.
     * @return {BindingsStream} A stream of bindings.
     */
    queryBindings(endpoint: string, query: string, context?: ActionContext): BindingsStream;
    match(subject?: RegExp | RDF.Term, predicate?: RegExp | RDF.Term, object?: RegExp | RDF.Term, graph?: RegExp | RDF.Term): RDF.Stream;
}
